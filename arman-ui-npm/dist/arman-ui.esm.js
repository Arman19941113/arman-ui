import { openBlock, createBlock, createVNode, computed, ref, resolveComponent, createCommentVNode, renderSlot, toDisplayString, watch, onMounted, Transition, withCtx, withDirectives, withModifiers, vShow, watchEffect, withKeys, reactive, nextTick, Fragment, renderList, onUnmounted } from 'vue';

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var defineProperty = _defineProperty;

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}
var arrayWithHoles = _arrayWithHoles;

function _iterableToArrayLimit(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;
  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }
  return _arr;
}
var iterableToArrayLimit = _iterableToArrayLimit;

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
var arrayLikeToArray = _arrayLikeToArray;

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);
}
var unsupportedIterableToArray = _unsupportedIterableToArray;

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
var nonIterableRest = _nonIterableRest;

function _slicedToArray(arr, i) {
  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();
}
var slicedToArray = _slicedToArray;

!function (t) {
  var l,
      o,
      _c,
      a,
      e,
      i,
      _L,
      d = '<svg><symbol id="icon-revoke" viewBox="0 0 1024 1024"><path d="M534.3955121 343.06275555h-6.34323753l-0.77672296-142.78757136c0-52.94661531-43.88484741-73.78868148-81.29700346-43.62593974L97.87720691 436.65787259c-37.41215605 30.0332879-37.41215605 79.22574222 0.12945384 109.25903013L443.38947161 823.07754667c37.41215605 30.0332879 88.93477925-0.51781531 88.93477925-45.17938569V628.50844445h33.78744889c151.0726163 0 266.28652247 65.24472889 336.83885828 191.20330272 13.8515595 22.91332741 28.47984197 17.86462815 28.47984197 0-3.10689185-224.34348247-185.11897283-476.51953778-403.37812543-476.51953778h6.34323753z m-6.47269135-0.12945382"  ></path></symbol><symbol id="icon-close-bold" viewBox="0 0 1024 1024"><path d="M743.30435795 685.58610649L573.64763521 512.00343486l169.67962166-173.60728741c19.40247373-15.57556146 21.42555638-42.40573703 4.54363522-59.97976532-16.85844996-17.5488402-46.28302603-19.16547411-65.68091976-3.61567358L512.00028642 448.92893711 341.81002767 274.80013625c-19.39846658-15.54980051-48.82246981-13.93316663-65.68091976 3.6156736-16.88249347 17.57402831-14.85883852 44.40477615 4.54363522 59.9797653l169.67962167 173.60728742L280.69564205 685.58610649c-19.42594495 15.56353998-21.4490276 42.4303528-4.54134549 59.96774384 16.85844996 17.58662263 46.28073632 19.2032565 65.68091976 3.62826792l170.1650701-174.1036122 170.16449727 174.1036122c19.40018402 15.57498916 48.8218975 13.95835472 65.68091975-3.62826792C764.75281324 728.01645929 762.70396967 701.14907361 743.30435795 685.58610649z"  ></path></symbol><symbol id="icon-close" viewBox="0 0 1024 1024"><path d="M555.258667 514.3236084l196.22131347-196.98760986q9.26971435-8.50341797 9.26971435-21.23382569t-8.87420654-21.6293335-21.62933349-8.87420654-21.23382568 9.26971436l-196.98760987 196.22131348-196.98760986-196.22131348q-8.50341797-9.26971435-21.23382569-9.26971436t-21.62933349 8.87420654-8.87420655 21.62933351 9.26971436 21.23382568l196.22131347 196.98760985-196.22131348 196.98760987q-9.26971435 8.50341797-9.26971435 21.23382569t8.87420655 21.62933349 21.62933349 8.87420654 21.23382568-9.26971435l196.98760987-196.98760986 196.98760986 196.98760986q8.50341797 9.26971435 21.23382569 9.26971435t21.62933349-8.87420654 8.87420654-21.6293335-9.26971435-21.23382568z"  ></path></symbol><symbol id="icon-bold-arrow" viewBox="0 0 1024 1024"><path d="M819.07712 478.69952l-225.4848 191.488a81.73568 81.73568 0 0 1-53.0432 19.47648 81.77664 81.77664 0 0 1-53.02272-19.47648l-225.4848-191.488a81.92 81.92 0 1 1 106.06592-124.86656l172.4416 146.45248 172.46208-146.45248a81.92 81.92 0 0 1 106.06592 124.86656z"  ></path></symbol><symbol id="icon-odd-arrow" viewBox="0 0 1024 1024"><path d="M807.33635805 347.60094339c-24.7326014-26.18746016-64.01379164-1.45485877-174.58306858 109.11441814l-120.75328947 120.75328947-122.20814824-122.20814822c-122.20814824-122.20814824-168.76363352-144.03103211-180.40250483-82.926958-7.27429443 32.00689583 266.23918035 314.2495238 302.61065307 314.24952439C541.09717829 686.58306917 817.5203706 408.70501752 817.5203706 379.60783922 817.5203706 366.51410912 813.15579371 351.96552028 807.33635805 347.60094339z"  ></path></symbol><symbol id="icon-love" viewBox="0 0 1024 1024"><path d="M512 922.110425c-0.002047 0-0.004093 0-0.00614 0-5.574972-0.002047-10.916631-2.229784-14.84101-6.186909L370.833887 788.530081c-1.613754-1.622964-164.173107-165.007101-187.469696-188.304713C114.596991 531.459191 74.209142 454.2886 66.567092 377.057635c-7.609305-76.902484 18.981307-150.036132 74.874291-205.929116 54.793954-54.79293 121.562637-77.752852 193.072297-66.412572 59.33027 9.41237 120.361275 42.176588 177.48632 95.104031 57.122999-52.92642 118.155027-85.690638 177.485297-95.104031 71.513754-11.351536 138.279367 11.616572 193.072297 66.412572 55.891961 55.892985 82.482573 129.026632 74.874291 205.929116-7.643074 77.230965-48.0299 154.400532-116.7971 223.167732-50.870598 50.868551-311.172065 313.063135-313.795822 315.705312C522.914584 919.886781 517.572926 922.110425 512 922.110425zM298.928207 143.679353c-47.080272 0-89.998757 19.104103-127.914298 57.020668-47.547923 47.547923-69.27476 107.107413-62.829977 172.238806 6.67912 67.496254 42.902112 135.863341 104.751762 197.714014 23.334451 23.334451 185.92962 186.758498 187.568956 188.406021l111.505583 112.451118c56.269561-56.671721 255.224846-257.029958 299.05305-300.858162 61.850673-61.850673 98.073666-130.216737 104.750739-197.714014 6.446829-65.131393-15.280008-124.690884-62.828954-172.238806-45.573965-45.574988-98.377588-63.974034-156.947542-54.680367-55.707766 8.838296-114.234741 42.590004-169.251775 97.609085-3.922333 3.921309-9.240455 6.125511-14.785751 6.125511s-10.863419-2.203178-14.785751-6.124488c-55.020104-55.020104-113.546056-88.772836-169.252799-97.610108C318.119291 144.458089 308.437791 143.679353 298.928207 143.679353z"  ></path></symbol><symbol id="icon-edit" viewBox="0 0 1024 1024"><path d="M908.785955 492.415966c-11.04966 0-20.008706 8.958022-20.008706 20.008706l0 338.328565c0 38.614459-31.416524 70.030983-70.030983 70.030983L202.707748 920.78422c-38.614459 0-70.030983-31.416524-70.030983-70.030983l0-676.303067c0-38.614459 31.416524-70.030983 70.030983-70.030983l362.378308 0c11.04966 0 20.008706-8.958022 20.008706-20.008706 0-11.050684-8.959046-20.008706-20.008706-20.008706L202.707748 64.401776c-60.681034 0-110.049418 49.367361-110.049418 110.049418l0 676.303067c0 60.681034 49.367361 110.049418 110.049418 110.049418l616.038518 0c60.681034 0 110.049418-49.367361 110.049418-110.049418L928.795685 512.425695C928.795685 501.373988 919.836639 492.415966 908.785955 492.415966z"  ></path><path d="M942.576549 117.985158 907.20597 82.614579c-23.405059-23.405059-61.486376-23.400966-84.891436 0l-422.369633 422.36861c-1.295506 1.296529-2.407839 2.76395-3.304256 4.363378L269.318842 736.416166c-4.457522 7.951089-2.977821 17.909905 3.598968 24.221658 3.830235 3.675716 8.823969 5.572926 13.859659 5.572926 3.613294 0 7.247054-0.977257 10.488889-2.973728l219.285309-135.104047c1.327228-0.816598 2.552126-1.784646 3.654226-2.885723l422.369633-422.36861C965.979562 179.471534 965.979562 141.390217 942.576549 117.985158zM418.556794 552.080857l55.42124 55.279001-132.025942 81.343633L418.556794 552.080857zM914.279063 174.579107 505.926678 582.930469l-63.748906-63.586201L850.612021 110.912066c7.798617-7.800663 20.493753-7.804756 28.29544 0l35.371602 35.371602C922.081773 154.084331 922.081773 166.777421 914.279063 174.579107z"  ></path></symbol><symbol id="icon-clear" viewBox="0 0 1024 1024"><path d="M605.76875 833.4125a31.78125 31.78125 0 0 1-31.275-32.11875V383.4125c0-17.71875 14.00625-32.11875 31.275-32.11875s31.275 14.4 31.275 32.11875v417.88125a31.66875 31.66875 0 0 1-31.275 32.11875z m-187.5375 0a31.78125 31.78125 0 0 1-31.275-32.11875V383.4125c0-17.71875 14.00625-32.11875 31.275-32.11875s31.275 14.4 31.275 32.11875v417.88125a31.66875 31.66875 0 0 1-31.275 32.11875z m-156.2625 64.29375V254.825h500.00625v642.88125H261.96875zM433.86875 190.5875V126.29375h156.2625v64.29375H433.86875z m421.875 0H652.625V94.175a31.66875 31.66875 0 0 0-31.275-32.11875H402.59375a31.78125 31.78125 0 0 0-31.275 32.11875v96.4125H168.2c-17.26875 0-31.275 14.4-31.275 32.11875s14.00625 32.11875 31.275 32.11875h31.21875v675c0 17.71875 14.00625 32.11875 31.275 32.11875h562.5a31.725 31.725 0 0 0 31.275-32.11875v-675h31.275c17.26875 0 31.275-14.4 31.275-32.11875s-14.00625-32.11875-31.275-32.11875z"  ></path></symbol><symbol id="icon-play" viewBox="0 0 1024 1024"><path d="M512 960C264.576 960 64 759.424 64 512S264.576 64 512 64s448 200.576 448 448-200.576 448-448 448z m0-64c212.077 0 384-171.923 384-384S724.077 128 512 128 128 299.923 128 512s171.923 384 384 384z m134.51-329.505L442.78 691.96c-15.048 9.267-34.76 4.58-44.028-10.468a32 32 0 0 1-4.752-16.78V359.288c0-17.673 14.327-32 32-32a32 32 0 0 1 16.78 4.752l203.73 125.465c30.097 18.535 39.47 57.958 20.935 88.055a64 64 0 0 1-20.935 20.935z"  ></path></symbol><symbol id="icon-github" viewBox="0 0 1024 1024"><path d="M512 12.63616c-282.74688 0-512 229.21216-512 512 0 226.22208 146.69824 418.14016 350.12608 485.82656 25.57952 4.73088 35.00032-11.10016 35.00032-24.63744 0-12.20608-0.47104-52.55168-0.69632-95.31392-142.4384 30.96576-172.50304-60.416-172.50304-60.416-23.28576-59.16672-56.85248-74.91584-56.85248-74.91584-46.44864-31.78496 3.50208-31.1296 3.50208-31.1296 51.4048 3.60448 78.47936 52.75648 78.47936 52.75648 45.6704 78.27456 119.76704 55.64416 149.01248 42.55744 4.58752-33.09568 17.85856-55.68512 32.50176-68.46464-113.72544-12.94336-233.2672-56.85248-233.2672-253.0304 0-55.88992 20.00896-101.5808 52.75648-137.4208-5.3248-12.9024-22.85568-64.96256 4.95616-135.49568 0 0 43.008-13.74208 140.84096 52.49024 40.83712-11.34592 84.64384-17.03936 128.16384-17.24416 43.49952 0.2048 87.32672 5.87776 128.24576 17.24416 97.73056-66.2528 140.65664-52.49024 140.65664-52.49024 27.87328 70.53312 10.3424 122.59328 5.03808 135.49568 32.82944 35.86048 52.69504 81.53088 52.69504 137.4208 0 196.64896-119.78752 239.94368-233.79968 252.6208 18.37056 15.89248 34.73408 47.04256 34.73408 94.80192 0 68.5056-0.59392 123.63776-0.59392 140.51328 0 13.6192 9.216 29.5936 35.16416 24.576 203.32544-67.76832 349.83936-259.62496 349.83936-485.76512 0-282.78784-229.23264-512-512-512z"  ></path></symbol><symbol id="icon-add" viewBox="0 0 1024 1024"><path d="M883.47904743 413.98436447L613.66438146 413.98436447l0-266.11748652c0-54.8590994-42.02515175-100.45848144-96.88425116-100.45848144l-1.36238057 0c-54.86034094 0-101.024795 45.59938324-101.024795 100.45848144l0 266.11748652L148.72007293 413.98436447c-54.86034094 0-100.90308737 45.72729981-100.90308736 100.58143183l0 1.36238056c0 54.86034094 46.04274642 97.32761433 100.90308736 97.32761434l265.6728818 0 0 269.37006125c0 54.86034094 46.16445406 97.2059067 101.024795 97.20590671l1.36238057 0c54.8590994 0 96.88425116-42.34556575 96.88425116-97.20590671L613.66438146 613.2557912l269.81342443 0c54.8590994 0 96.76130198-42.46851615 96.76130198-97.32761434l0-1.36238056C980.24034941 459.71166428 938.33193791 413.98436447 883.47904743 413.98436447L883.47904743 413.98436447zM883.47904743 413.98436447"  ></path></symbol><symbol id="icon-lighting" viewBox="0 0 1024 1024"><path d="M353.6627293 947.82480137L439.26490127 536.04278984H208.45459707a15.62778106 15.62778106 0 0 1-14.57591045-21.28784237L353.86308565 101.26990917A45.78138369 45.78138369 0 0 1 396.58903789 72.01790878h252.99974883a20.03561631 20.03561631 0 0 1 18.73330224 27.34861641L576.10816279 336.38787002l247.38977637 1.15204834a7.71371279 7.71371279 0 0 1 6.06077402 12.47217099l-469.83520986 600.66778711a3.45614414 3.45614414 0 0 1-6.06077402-2.8550751z" fill="#FFF100" ></path><path d="M208.45459707 536.04278984h31.15538437L409.21147636 72.01790878h-12.62243847a45.78138369 45.78138369 0 0 0-42.72595224 29.25200039L193.87868662 514.75494746a15.62778106 15.62778106 0 0 0 14.57591045 21.28784238z" fill="#FFFFFF" ></path><path d="M825.45141201 335.28591143h-38.0175829L370.24220146 875.3459583l-14.62599931 70.1246584a3.45614414 3.45614414 0 0 0 6.11086289 2.80498622l469.785121-600.5175205a7.71371279 7.71371279 0 0 0-6.06077403-12.47217099z" fill="#F8B62D" ></path><path d="M303.92431104 240.41726651a10.01780859 10.01780859 0 0 1-9.36665069-13.67430821l18.8334791-48.68654853a10.01780859 10.01780859 0 0 1 18.6832125 7.21282148L313.04051651 234.00586953a10.01780859 10.01780859 0 0 1-9.11620547 6.41139698zM357.06878369 962a13.6743082 13.6743082 0 0 1-5.7101502-1.25222607 13.47395185 13.47395185 0 0 1-7.51335644-15.02671289l83.09771983-399.6604626H208.45459707a25.64558965 25.64558965 0 0 1-23.89247227-35.0623292l87.65582257-226.65291328a10.01780859 10.01780859 0 1 1 18.6832125 7.21282237L203.2453373 518.3613582a5.60997246 5.60997246 0 0 0 5.00890431 7.66362393h243.33256405l-82.39647392 396.2544082 60.75800771-77.63801484a10.01780859 10.01780859 0 1 1 15.77804854 12.32190439L367.63757158 956.84082911a13.37377412 13.37377412 0 0 1-10.56878789 5.15917089z" fill="#231815" ></path><path d="M485.64735401 799.71150518a10.01780859 10.01780859 0 0 1-7.91406914-16.17876036L818.93983643 347.50763721l-257.45767383-1.20213721 97.4732748-250.44520781a10.01780859 10.01780859 0 0 0-1.05186972-9.31656182 10.01780859 10.01780859 0 0 0-8.31478096-4.50801386H396.58903789A36.01402119 36.01402119 0 0 0 363.12955771 104.92640878l-13.52404072 35.06232921a10.01780859 10.01780859 0 1 1-18.6832125-7.21282236l13.52404072-35.0623292A56.19990498 56.19990498 0 0 1 396.58903789 62.00010019h252.99974883a30.0534249 30.0534249 0 0 1 28.04986318 41.02292549l-86.90448691 223.39712549 232.81386592 1.1019586a17.78160938 17.78160938 0 0 1 13.92475341 28.65093222L493.36106592 795.85464922a10.01780859 10.01780859 0 0 1-7.71371191 3.85685596z" fill="#231815" ></path></symbol><symbol id="icon-arrow-up" viewBox="0 0 1024 1024"><path d="M77.4 732.1c-17.5-17.5-17.5-45.8 0-63.3l370.2-370.2c35-35 91.7-35 126.6 0l372.9 372.9c17.3 17.3 17.5 45.3 0.5 62.8-17.4 17.9-46.1 18.1-63.8 0.5L542.6 393.5c-17.5-17.5-45.8-17.5-63.3 0L140.7 732.1c-17.5 17.5-45.8 17.5-63.3 0z"  ></path></symbol><symbol id="icon-arrow-down" viewBox="0 0 1024 1024"><path d="M946.59999999 291.9c17.5 17.5 17.5 45.8 0 63.3l-370.19999999 370.2c-35 35-91.7 35-126.6 1e-8l-372.9-372.9c-17.3-17.3-17.5-45.3-0.5-62.80000001 17.4-17.9 46.1-18.1 63.8-0.5L481.40000001 630.5c17.5 17.5 45.8 17.5 63.29999999 1e-8L883.3 291.90000001c17.5-17.5 45.8-17.5 63.29999999-1e-8z"  ></path></symbol><symbol id="icon-arrow-left" viewBox="0 0 1024 1024"><path d="M732.1 946.59999999c-17.5 17.5-45.8 17.5-63.3 0l-370.2-370.19999999c-35-35-35-91.7-1e-8-126.6l372.9-372.9c17.3-17.3 45.3-17.5 62.80000001-0.5 17.9 17.4 18.1 46.1 0.5 63.8L393.5 481.40000001c-17.5 17.5-17.5 45.8-1e-8 63.29999999L732.09999999 883.3c17.5 17.5 17.5 45.8 1e-8 63.29999999z"  ></path></symbol><symbol id="icon-arrow-right" viewBox="0 0 1024 1024"><path d="M291.9 77.40000001c17.5-17.5 45.8-17.5 63.3 0l370.2 370.19999999c35 35 35 91.7 1e-8 126.6l-372.9 372.9c-17.3 17.3-45.3 17.5-62.80000001 0.5-17.9-17.4-18.1-46.1-0.5-63.8L630.5 542.59999999c17.5-17.5 17.5-45.8 1e-8-63.29999999L291.90000001 140.7c-17.5-17.5-17.5-45.8-1e-8-63.29999999z"  ></path></symbol><symbol id="icon-setting" viewBox="0 0 1024 1024"><path d="M921.07646036 437.07241162L861.71507422 437.07241162C854.95453174 437.07241162 846.73167383 430.96884893 844.27329747 422.9367295L809.34735166 338.24979511C806.21079981 332.50651279 807.63072734 322.31271464 812.29317119 317.67146387L854.14919961 275.77304844C861.92700312 268.08001631 866.18678047 257.80144677 866.18678047 246.88708965 866.18678047 235.93034727 861.92700312 225.6729708 854.21278057 218.00113086L805.95648652 169.57529404C790.59161269 154.37996651 763.78256036 154.31638731 748.24814551 169.66006631L706.37092403 211.68563925C701.83563682 216.17853945 693.90948535 218.99719883 683.99119443 213.88970322L599.36784013 179.15449766C592.98876758 177.26832617 586.99116933 169.06666396 586.99116933 162.28492754L586.99116933 102.90234834C586.99116933 80.35307422 568.59571162 62 546.00404873 62L477.88998506 62C455.38309707 62 437.07240898 80.35307422 437.07240898 102.90234834L437.07240898 162.28492754C437.07240898 168.89712119 430.8204957 177.26832617 422.91553378 179.6843208L338.27098555 214.65264922C332.73963213 217.70443057 322.14316924 216.17853945 317.65026817 211.72802539L275.64588828 169.68125937C260.23863096 154.37996651 233.34480722 154.37996651 217.9375499 169.72364463L169.68125674 217.9587456C161.92464541 225.6729708 157.66486719 235.93034727 157.66486719 246.88708965 157.66486719 257.80144677 161.92464541 268.08001631 169.6388706 275.73066318L211.60086523 317.71385C216.2633082 322.33390771 217.74681318 332.52770586 213.84731533 339.86045849L179.15449414 424.4626206C177.22593828 430.82049834 168.89711768 437.07241162 162.30611797 437.07241162L102.85995958 437.07241162C80.35307158 437.07241162 62.06357568 455.42548584 62.06357568 477.95356602L62.06357568 546.13120977C62.06357568 568.63810039 80.35307158 586.99117373 102.85995958 586.99117373L162.30611797 586.99117373C168.89711768 586.99117373 177.22593828 593.22189307 179.68431816 601.06327754L214.58906739 685.70782403C217.81039238 691.57826563 216.36927266 701.60252099 211.60086523 706.32854052L169.68125674 748.22695771C161.92464541 755.94118028 157.66486719 766.24094551 157.66486719 777.21888096 157.66486719 788.19681729 161.96703154 798.45419287 169.6388706 806.06245185L217.97993604 854.48828955C233.49315781 869.64123096 260.28101709 869.62003877 275.68827442 854.29755283L317.65026817 812.29317558C322.07959004 807.86385283 329.98455195 805.06638653 339.88164805 810.19507256L424.4414249 844.88789287C430.8204957 846.75287041 437.07240898 855.10288497 437.07240898 861.7362708L437.07240898 921.09765693C437.07240898 943.66812325 455.38309707 962.0000044 477.88998506 962.0000044L546.00404873 962.0000044C568.59571162 962.0000044 586.99116933 943.66812325 586.99116933 921.09765693L586.99116933 861.7362708C586.99116933 854.95453174 592.98876758 846.75287041 600.93611651 844.33687842L685.64424307 809.4321292C691.13321123 806.38034521 701.89921777 807.88504502 706.32854052 812.29317558L748.24814551 854.36113378C763.61301933 869.72600322 790.63400059 869.74719541 806.04125967 854.36113378L854.14919961 806.12603193C861.88461963 798.45419287 866.18678047 788.19681729 866.18678047 777.21888096 866.18678047 766.24094551 861.92700312 755.94118028 854.19158838 748.26934121L812.25078242 706.3921206C807.63072734 701.75086894 806.21079981 691.49349336 810.1314916 684.11835547L844.82431279 599.51619336C846.73167383 593.09473643 854.95453174 586.99117373 861.71507422 586.99117373L921.07646036 586.99117373C943.58335098 586.99117373 961.93642432 568.63810039 961.93642432 546.13120977L961.93642432 477.95356602C961.93642432 455.42548584 943.58335098 437.07241162 921.07646036 437.07241162L921.07646036 437.07241162ZM921.07646036 555.20178418L861.71507422 555.20178418C841.00958458 555.20178418 820.19813135 570.71500684 814.8998999 588.96211573L781.49985049 670.42772598C771.60275176 688.48409815 775.14197012 714.10634404 789.72270401 728.83543115L831.74827783 770.77623271C834.05830537 773.06506807 834.39739092 775.77776211 834.39739092 777.19768877 834.39739092 778.61761191 834.03711406 781.30911377 831.70588994 783.6191457L783.53436904 831.87543886C778.99908183 836.41072167 775.29032334 836.38952949 770.77622832 831.89663105L728.79304238 789.80747714C719.95558906 780.97002823 707.02790381 775.90491787 693.37966221 775.90491787 685.05083984 775.90491787 677.06110742 777.85466856 671.93241699 780.77929062L590.38203886 814.39127422C570.65142237 820.24051924 555.20177979 841.03078115 555.20177979 861.7362708L555.20177979 921.09765693C555.20177979 926.05680195 550.98438594 930.21061484 546.00404873 930.21061484L477.88998506 930.21061484C472.90964698 930.21061484 468.86179854 926.14157422 468.86179854 921.09765693L468.86179854 861.7362708C468.86179854 841.05197334 453.30619062 820.24051924 434.97430947 814.94228867L353.57227842 781.56343144C346.83292812 777.85466856 338.84319482 775.90491787 330.53556729 775.90491787 316.92970917 775.90491787 304.04441006 780.97002823 295.20695937 789.82867373L253.26615781 831.76947441C249.81171084 835.18153614 243.55979756 835.0543751 240.33847256 831.89663105L192.06098633 783.55556562C189.79334316 781.30911377 189.45425674 778.61761191 189.45425674 777.19768877 189.45425674 775.77776211 189.79334316 773.06506807 192.12456552 770.77623271L234.10775234 728.83543115C248.68848623 714.23350508 252.37605518 688.5900626 243.22071113 672.01719365L209.6087293 590.46681113C203.69590332 570.69381026 182.92683536 555.20178418 162.30611797 555.20178418L102.85995958 555.20178418C97.98558594 555.20178418 93.85296523 551.02677471 93.85296523 546.13120977L93.85296523 477.95356602C93.85296523 473.03680713 97.98558594 468.86180117 102.85995958 468.86180117L162.30611797 468.86180117C182.92683536 468.86180117 203.69590332 453.34857852 209.07890615 435.03789043L242.43657207 353.57228105C252.41844042 335.45232969 248.73087148 309.7876959 234.04417403 295.18576982L192.06098633 253.22377519C190.36555244 251.54953349 189.45425674 249.28189033 189.45425674 246.86589658 189.45425674 244.44990372 190.36555244 242.18226055 192.12456552 240.46563271L240.40205176 192.23053262C243.81411347 188.86085791 249.8964831 188.90324317 253.20257949 192.20933955L295.20695937 234.19252636C304.08679531 243.07236318 316.9932875 248.15866572 330.64153174 248.15866572 338.90677402 248.15866572 346.85412119 246.20891592 351.96161592 243.28429209L433.42722529 209.62992588C453.30619062 203.78067822 468.86179854 182.96922412 468.86179854 162.28492754L468.86179854 102.90234834C468.86179854 97.90081719 472.90964698 93.78938955 477.88998506 93.78938955L546.00404873 93.78938955C550.98438594 93.78938955 555.20177979 97.96439638 555.20177979 102.90234834L555.20177979 162.28492754C555.20177979 183.01160937 570.65142237 203.82306348 588.83495469 209.07890878L670.32175713 242.52134698C688.08142724 252.27009336 714.44542959 248.49775214 728.83542676 234.17133417L770.69145518 192.18814648C774.06113252 188.81847177 780.27066055 188.90324317 783.53436904 192.1033751L831.74827783 240.48682578C833.44371084 242.18226055 834.39739092 244.44990372 834.39739092 246.86589658 834.39739092 249.28189033 833.44371084 251.54953349 831.72708565 253.26616045L789.84986065 295.18576982C775.2055502 309.7876959 771.5179795 335.45232969 780.75809404 351.96161856L814.34888545 433.49080713C820.17693916 453.32738633 841.00958458 468.86180117 861.71507422 468.86180117L921.07646036 468.86180117C925.9508331 468.86180117 930.12584258 473.03680713 930.12584258 477.95356602L930.12584258 546.13120977C930.12584258 551.02677471 925.9508331 555.20178418 921.07646036 555.20178418ZM511.98940391 387.56573545C443.38790059 387.56573545 387.56573281 443.38790323 387.56573281 512.01060049 387.56573281 580.63329336 443.38790059 636.43426894 511.98940391 636.43426894 580.5697124 636.43426894 636.37068799 580.63329336 636.37068799 512.01060049 636.37068799 443.38790323 580.5697124 387.56573545 511.98940391 387.56573545L511.98940391 387.56573545ZM511.98940391 604.6448794C460.91445137 604.6448794 419.35512237 563.10674433 419.35512237 512.01060049 419.35512237 460.91445401 460.91445137 419.355125 511.98940391 419.355125 563.02197119 419.355125 604.58129844 460.91445401 604.58129844 512.01060049 604.58129844 563.10674433 563.02197119 604.6448794 511.98940391 604.6448794L511.98940391 604.6448794Z"  ></path></symbol><symbol id="icon-search" viewBox="0 0 1024 1024"><path d="M440.5625 749.65625C263.65625 749.65625 120.246875 608.75 120.246875 434.65625 120.246875 260.5625 263.65625 119.375 440.5625 119.375 617.46875 119.375 760.90625 260.5625 760.90625 434.65625 760.90625 608.75 617.46875 749.65625 440.5625 749.65625L440.5625 749.65625ZM953.225 912.78125L720.940625 684.125C781.746875 618.03125 819.125 530.84375 819.125 434.65625 819.125 228.78125 649.64375 62 440.5625 62 231.48125 62 62 228.78125 62 434.65625 62 640.25 231.48125 807.03125 440.5625 807.03125 530.9 807.03125 613.75625 775.8125 678.8375 723.78125L912.05 953.28125C923.440625 964.53125 941.8625 964.53125 953.225 953.28125 964.615625 942.3125 964.615625 924.03125 953.225 912.78125L953.225 912.78125Z"  ></path></symbol><symbol id="icon-loading" viewBox="0 0 1024 1024"><path d="M923.9890625 337.71025391c-22.66611328-53.58867188-55.10917969-101.71142578-96.42744141-143.0296875-41.31914062-41.31826172-89.44101563-73.76132812-143.0296875-96.42744141C629.03603516 74.78105469 570.10097656 62.87890625 509.36328125 62.87890625c-1.97050781 0-3.9375 0.01318359-5.90185547 0.03779297-14.56083984 0.18544922-26.21425781 12.13945313-26.02880859 26.70117187 0.18369141 14.44746094 11.95224609 26.03144531 26.35839844 26.03144532l0.34277343-0.00175782c1.74023438-0.02285156 3.48310547-0.03427734 5.22949219-0.03427734 53.64228516 0 105.665625 10.50029297 154.62597656 31.20820312 47.30273438 20.00742187 89.79082031 48.65537109 126.28388672 85.1475586s65.14013672 78.98027344 85.1484375 126.28388672C896.12949219 407.21328125 906.62890625 459.23662109 906.62890625 512.87890625c0 14.56171875 11.80546875 26.3671875 26.3671875 26.3671875s26.3671875-11.80546875 26.3671875-26.3671875c0-60.73769531-11.90126953-119.67363281-35.37421875-175.16865234z"  ></path></symbol><symbol id="icon-loading-dot" viewBox="0 0 1024 1024"><path d="M313.76768 778.79936q0 28.39104-20.088 48.47904t-48.47904 20.088q-27.85536 0-48.2112-20.35584t-20.35584-48.2112q0-28.39104 20.088-48.47904t48.47904-20.088 48.47904 20.088 20.088 48.47904z m266.76864 110.35008q0 28.39104-20.088 48.47904t-48.47904 20.088-48.47904-20.088-20.088-48.47904 20.088-48.47904 48.47904-20.088 48.47904 20.088 20.088 48.47904z m-377.11872-377.11872q0 28.39104-20.088 48.47904t-48.47904 20.088-48.47904-20.088-20.088-48.47904 20.088-48.47904 48.47904-20.088 48.47904 20.088 20.088 48.47904z m643.88736 266.76864q0 27.85536-20.35584 48.2112t-48.2112 20.35584q-28.39104 0-48.47904-20.088t-20.088-48.47904 20.088-48.47904 48.47904-20.088 48.47904 20.088 20.088 48.47904z m-516.39552-533.53728q0 35.35488-25.17696 60.53184t-60.53184 25.17696-60.53184-25.17696-25.17696-60.53184 25.17696-60.53184 60.53184-25.17696 60.53184 25.17696 25.17696 60.53184z m626.7456 266.76864q0 28.39104-20.088 48.47904t-48.47904 20.088-48.47904-20.088-20.088-48.47904 20.088-48.47904 48.47904-20.088 48.47904 20.088 20.088 48.47904z m-342.8352-377.11872q0 42.8544-29.99808 72.85248t-72.85248 29.99808-72.85248-29.99808-29.99808-72.85248 29.99808-72.85248 72.85248-29.99808 72.85248 29.99808 29.99808 72.85248z m283.9104 110.35008q0 49.81824-35.35488 84.90528t-84.63744 35.08704q-49.81824 0-84.90528-35.08704t-35.08704-84.90528q0-49.28256 35.08704-84.63744t84.90528-35.35488q49.28256 0 84.63744 35.35488t35.35488 84.63744z"  ></path></symbol><symbol id="icon-good" viewBox="0 0 1024 1024"><path d="M641.9245678 961.08709539c-81.90896689 0-186.41351111-11.29778866-313.51363145-31.06891852l-22.59557732-2.82444747V407.49545578l11.29778867-8.47334119c2.82444747 0 172.29127498-118.62678035 228.78021828-310.68918519l2.82444627-11.29778865 8.47334241-5.64889373c8.47334119-5.64889373 76.26007316-50.84004837 127.10012032-11.29778866 50.84004837 39.54225971 48.01560091 146.8712514-11.29778867 330.46031504 79.08451942 0 225.95577083 8.47334119 262.67358429 79.08451942 14.12223613 31.06891852 8.47334119 67.78673076-22.59557733 107.32899169 8.47334119 16.94668239 19.77112986 42.36670718 11.29778866 67.78673075-5.64889373 19.77112986-16.94668239 33.89336598-36.71781224 48.01560213 8.47334119 16.94668239 16.94668239 42.36670718 11.29778867 64.96228329-2.82444747 11.29778866-11.29778866 28.24447105-25.4200248 39.54225971 11.29778866 25.4200248 14.12223613 59.31338957-2.82444747 87.55786183-25.4200248 53.66449584-101.68009675 76.26007316-228.78021829 76.26007317zM362.30430113 879.1781285c384.12481089 59.31338957 451.91154164 2.82444747 463.20933152-16.9466836 14.12223613-22.59557732-8.47334119-53.66449584-8.47334118-53.66449584l-22.59557734-31.06891852 33.89336478-14.12223492c8.47334119-2.82444747 19.77112986-8.47334119 19.77113106-16.94668361 2.82444747-11.29778866-8.47334119-33.89336598-19.77113106-45.19115343l-28.24447105-31.06891852 39.54225971-14.12223612c11.29778866-2.82444747 28.24447105-11.29778866 31.06891852-22.59557734 2.82444747-11.29778866-8.47334119-31.06891852-14.12223491-36.71781223l-16.94668361-19.77112986 16.94668361-19.77112985c14.12223613-16.94668239 36.71781225-45.19115466 28.24447104-62.13783705-19.77112986-39.54225971-160.99348631-50.84004837-248.55134814-45.19115464l-42.36670719 5.64889372 14.12223613-39.54225971c87.55786183-257.02468934 50.84004837-302.21584399 42.36670719-307.86473773-11.29778866-8.47334119-36.71781225 0-53.66449584 8.47334121-53.66449584 175.11572244-192.06240483 290.91805533-234.42911324 321.98697384V879.1781285z"  ></path><path d="M362.30430113 978.03377778h-282.44471292v-621.37837037h279.62026667v621.37837037z m-225.95577082-56.48894332h166.64238125v-508.40048374H136.34853031v508.40048374z"  ></path></symbol><symbol id="icon-download" viewBox="0 0 1024 1024"><path d="M466.48888853 147.91111147v364.08888853H329.9555552l182.0444448 182.0444448 182.0444448-182.0444448h-136.53333333V147.91111147z"  ></path><path d="M876.08888853 785.06666667H147.91111147v-364.08888854H56.88888853v409.6a45.51111147 45.51111147 0 0 0 45.51111147 45.5111104h819.2a45.51111147 45.51111147 0 0 0 45.51111147-45.5111104v-409.6h-91.02222294v364.08888854z"  ></path></symbol></svg>',
      n = (l = document.getElementsByTagName("script"))[l.length - 1].getAttribute("data-injectcss");
  if (n && !t.__iconfont__svg__cssinject__) {
    t.__iconfont__svg__cssinject__ = !0;
    try {
      document.write("<style>.svgfont {display: inline-block;width: 1em;height: 1em;fill: currentColor;vertical-align: -0.1em;font-size:16px;}</style>");
    } catch (t) {
      console && console.log(t);
    }
  }
  function h() {
    i || (i = !0, a());
  }
  o = function o() {
    var t,
        l,
        o,
        c,
        a,
        e = document.createElement("div");
    e.innerHTML = d, d = null, (t = e.getElementsByTagName("svg")[0]) && (t.setAttribute("aria-hidden", "true"), t.style.position = "absolute", t.style.width = 0, t.style.height = 0, t.style.overflow = "hidden", l = t, (o = document.body).firstChild ? (c = l, (a = o.firstChild).parentNode.insertBefore(c, a)) : o.appendChild(l));
  }, document.addEventListener ? ~["complete", "loaded", "interactive"].indexOf(document.readyState) ? setTimeout(o, 0) : (_c = function c() {
    document.removeEventListener("DOMContentLoaded", _c, !1), o();
  }, document.addEventListener("DOMContentLoaded", _c, !1)) : document.attachEvent && (a = o, e = t.document, i = !1, (_L = function L() {
    try {
      e.documentElement.doScroll("left");
    } catch (t) {
      return void setTimeout(_L, 50);
    }
    h();
  })(), e.onreadystatechange = function () {
    "complete" == e.readyState && (e.onreadystatechange = null, h());
  });
}(window);

var script = {
  name: 'AIcon',
  props: {
    name: {
      type: String,
      required: true
    },
    width: {
      type: [Number, String],
      "default": ''
    },
    color: {
      type: String,
      "default": ''
    }
  }
};

function render(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createBlock("svg", {
    class: "a-icon",
    style: { 'font-size': _ctx.width && _ctx.width + 'px', color: _ctx.color }
  }, [
    createVNode("use", {'xlink:href':`#icon-${_ctx.name}`}, null, 16 /* FULL_PROPS */)
  ], 4 /* STYLE */))
}

script.render = render;
script.__file = "src/components/icon/icon.vue";

var script$1 = {
  name: 'AButton',
  components: {
    AIcon: script
  },
  props: {
    theme: {
      type: String,
      "default": 'default',
      validator: function validator(value) {
        if (['default', 'primary', 'success', 'warning', 'danger'].includes(value)) {
          return true;
        } else {
          console.error("theme property is not valid: '".concat(value, "'"));
          return false;
        }
      }
    },
    leftIcon: {
      type: String,
      "default": ''
    },
    rightIcon: {
      type: String,
      "default": ''
    },
    loading: {
      type: Boolean,
      "default": false
    },
    loadingText: {
      type: String,
      "default": ''
    },
    round: {
      type: Boolean,
      "default": false
    },
    disabled: {
      type: Boolean,
      "default": false
    }
  },
  setup: function setup(props, context) {
    var _useClickButton = useClickButton(),
        isClicked = _useClickButton.isClicked,
        handleClick = _useClickButton.handleClick;
    var hasSlots = computed(function () {
      return Boolean(context.slots["default"]);
    });
    return {
      isClicked: isClicked,
      handleClick: handleClick,
      hasSlots: hasSlots
    };
  }
};
function useClickButton() {
  var isClicked = ref(false);
  function handleClick() {
    isClicked.value = true;
    setTimeout(function () {
      isClicked.value = false;
    }, 300);
  }
  return {
    isClicked: isClicked,
    handleClick: handleClick
  };
}

const _hoisted_1 = {
  key: 0,
  class: "a-button-loading"
};
const _hoisted_2 = {
  key: 0,
  class: "loading-text"
};

function render$1(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_AIcon = resolveComponent("AIcon");

  return (openBlock(), createBlock("button", {
    class: ['a-button', 'a-button-' + _ctx.theme, _ctx.isClicked && 'isClicked', _ctx.loading && 'is-loading', _ctx.round && 'is-round'],
    style: { padding: !_ctx.hasSlots && '0 7px' },
    disabled: _ctx.disabled,
    onClick: _cache[1] || (_cache[1] = (...args) => (_ctx.handleClick(...args)))
  }, [
    createVNode("div", {
      class: "a-button-content",
      style: { visibility: _ctx.loading ? 'hidden' : 'inherit' }
    }, [
      (_ctx.leftIcon)
        ? createVNode(_component_AIcon, {
            key: 0,
            name: _ctx.leftIcon,
            width: "16",
            class: "button-icon"
          }, null, 8 /* PROPS */, ["name"])
        : createCommentVNode("v-if", true),
      createVNode("span", {
        class: "button-text",
        style: { 'margin-left': _ctx.leftIcon && _ctx.hasSlots && '5px', 'margin-right': _ctx.rightIcon && _ctx.hasSlots && '5px' }
      }, [
        renderSlot(_ctx.$slots, "default")
      ], 4 /* STYLE */),
      (_ctx.rightIcon)
        ? createVNode(_component_AIcon, {
            key: 1,
            name: _ctx.rightIcon,
            width: "16",
            class: "button-icon"
          }, null, 8 /* PROPS */, ["name"])
        : createCommentVNode("v-if", true)
    ], 4 /* STYLE */),
    (_ctx.loading)
      ? (openBlock(), createBlock("div", _hoisted_1, [
          createVNode(_component_AIcon, {
            name: "loading",
            width: "20",
            color: _ctx.theme === 'default' ? '' : '#FFF',
            class: "loading-icon"
          }, null, 8 /* PROPS */, ["color"]),
          (_ctx.loadingText)
            ? (openBlock(), createBlock("span", _hoisted_2, toDisplayString(_ctx.loadingText), 1 /* TEXT */))
            : createCommentVNode("v-if", true)
        ]))
      : createCommentVNode("v-if", true)
  ], 14 /* CLASS, STYLE, PROPS */, ["disabled"]))
}

script$1.render = render$1;
script$1.__file = "src/components/button/button.vue";

var script$2 = {
  name: 'AInput',
  components: {
    AIcon: script
  },
  props: {
    type: {
      type: String,
      "default": 'text',
      validator: function validator(val) {
        return ['text', 'number'].includes(val);
      }
    },
    modelValue: {
      type: [String, Number],
      "default": ''
    },
    placeholder: {
      type: String,
      "default": '请输入'
    },
    rightIcon: {
      type: String,
      "default": ''
    },
    disabled: {
      type: Boolean,
      "default": false
    },
    round: {
      type: Boolean,
      "default": false
    }
  }
};

function render$2(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_AIcon = resolveComponent("AIcon");

  return (openBlock(), createBlock("div", {
    class: ['a-input', _ctx.rightIcon && 'has-right-icon']
  }, [
    createVNode("input", {
      type: _ctx.type,
      class: ['a-input-box', _ctx.round && 'round'],
      value: _ctx.modelValue,
      disabled: _ctx.disabled,
      placeholder: _ctx.placeholder,
      onBlur: _cache[1] || (_cache[1] = $event => (_ctx.$emit('blur', $event))),
      onFocus: _cache[2] || (_cache[2] = $event => (_ctx.$emit('focus', $event))),
      onInput: _cache[3] || (_cache[3] = $event => (_ctx.$emit('update:modelValue', $event.target.value)))
    }, null, 42 /* CLASS, PROPS, HYDRATE_EVENTS */, ["type", "value", "disabled", "placeholder"]),
    (_ctx.rightIcon)
      ? createVNode(_component_AIcon, {
          key: 0,
          name: _ctx.rightIcon,
          width: "16",
          class: "right-icon"
        }, null, 8 /* PROPS */, ["name"])
      : createCommentVNode("v-if", true)
  ], 2 /* CLASS */))
}

script$2.render = render$2;
script$2.__file = "src/components/input/input.vue";

var defaultManager = {
  stack: 2000,
  nextStack: function nextStack() {
    return ++this.stack;
  }
};
var stackManager = window['__STACK_MANAGER__'] || (window['__STACK_MANAGER__'] = defaultManager);

var script$3 = {
  name: 'ALoading',
  props: {
    value: {
      type: Boolean,
      "default": false
    },
    type: {
      type: String,
      "default": 'default',
      validator: function validator(value) {
        if (['default', 'linear', 'wave', 'dots'].includes(value)) {
          return true;
        } else {
          console.error("type property is not valid: '".concat(value, "'"));
          return false;
        }
      }
    },
    width: {
      type: [Number, String],
      "default": 40
    },
    global: {
      type: Boolean,
      "default": false
    },
    background: {
      type: String,
      "default": 'rgba(255, 255, 255, .8)'
    },
    text: {
      type: String,
      "default": ''
    }
  },
  setup: function setup(props) {
    var root = ref(null);
    var zIndex = ref(0);
    watch(function () {
      return props.value;
    }, function (val) {
      if (val) zIndex.value = stackManager.nextStack();
    }, {
      immediate: true
    });
    onMounted(function () {
      var parentNode = root.value.parentNode;
      if (getComputedStyle(parentNode).position === 'static') {
        parentNode.style.position = 'relative';
      }
    });
    return {
      root: root,
      zIndex: zIndex,
      computedSize: computed(function () {
        return {
          width: props.width + 'px',
          height: props.width + 'px'
        };
      }),
      computedSizeHalf: computed(function () {
        return {
          width: props.width / 2 + 'px',
          height: props.width / 2 + 'px'
        };
      })
    };
  }
};

const _hoisted_1$1 = /*#__PURE__*/createVNode("circle", {
  cx: "32",
  cy: "32",
  r: "29",
  fill: "none",
  stroke: "#409EFF",
  "stroke-width": "6",
  "stroke-linecap": "round"
}, null, -1 /* HOISTED */);
const _hoisted_2$1 = /*#__PURE__*/createVNode("circle", {
  cx: "32",
  cy: "32",
  r: "29",
  fill: "none",
  stroke: "#409EFF",
  "stroke-width": "6",
  "stroke-linecap": "round",
  "stroke-dasharray": "60,200"
}, [
  /*#__PURE__*/createVNode("animateTransform", {
    attributeName: "transform",
    type: "rotate",
    begin: "0s",
    dur: "1s",
    from: "0 32 32",
    to: "360 32 32",
    repeatCount: "indefinite"
  })
], -1 /* HOISTED */);
const _hoisted_3 = {
  key: 4,
  class: "a-loading-text"
};

function render$3(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createBlock(Transition, { name: "fade" }, {
    default: withCtx(() => [
      withDirectives(createVNode("div", {
        ref: "root",
        class: "a-loading",
        style: { position: _ctx.global && 'fixed', zIndex: _ctx.zIndex, background: _ctx.background },
        onClick: _cache[1] || (_cache[1] = withModifiers(() => {}, ["stop"]))
      }, [
        createCommentVNode(" 变化圆弧 "),
        (_ctx.type === 'default')
          ? (openBlock(), createBlock("svg", {
              key: 0,
              style: _ctx.computedSize,
              class: "flex-loading",
              viewBox: "0 0 64 64",
              xmlns: "http://www.w3.org/2000/svg"
            }, [
              _hoisted_1$1
            ], 4 /* STYLE */))
          : createCommentVNode("v-if", true),
        createCommentVNode(" 普通圆弧 "),
        (_ctx.type === 'linear')
          ? (openBlock(), createBlock("svg", {
              key: 1,
              style: _ctx.computedSize,
              viewBox: "0 0 64 64",
              xmlns: "http://www.w3.org/2000/svg"
            }, [
              _hoisted_2$1
            ], 4 /* STYLE */))
          : createCommentVNode("v-if", true),
        createCommentVNode(" 扩散圆圈 "),
        (_ctx.type === 'wave')
          ? (openBlock(), createBlock("div", {
              key: 2,
              style: _ctx.computedSize,
              class: "wave-loading"
            }, null, 4 /* STYLE */))
          : createCommentVNode("v-if", true),
        createCommentVNode(" 四点旋转 "),
        (_ctx.type === 'dots')
          ? (openBlock(), createBlock("div", {
              key: 3,
              style: _ctx.computedSize,
              class: "dots-loading"
            }, [
              createVNode("div", {
                class: "dots-loading-item",
                style: _ctx.computedSizeHalf
              }, null, 4 /* STYLE */),
              createVNode("div", {
                class: "dots-loading-item",
                style: _ctx.computedSizeHalf
              }, null, 4 /* STYLE */),
              createVNode("div", {
                class: "dots-loading-item",
                style: _ctx.computedSizeHalf
              }, null, 4 /* STYLE */),
              createVNode("div", {
                class: "dots-loading-item",
                style: _ctx.computedSizeHalf
              }, null, 4 /* STYLE */)
            ], 4 /* STYLE */))
          : createCommentVNode("v-if", true),
        (_ctx.text)
          ? (openBlock(), createBlock("div", _hoisted_3, toDisplayString(_ctx.text), 1 /* TEXT */))
          : createCommentVNode("v-if", true)
      ], 4 /* STYLE */), [
        [vShow, _ctx.value]
      ])
    ]),
    _: 1
  }))
}

script$3.render = render$3;
script$3.__file = "src/components/loading/loading.vue";

function getBoundingClientRect(element) {
  var rect = element.getBoundingClientRect();
  return {
    width: rect.width,
    height: rect.height,
    top: rect.top,
    right: rect.right,
    bottom: rect.bottom,
    left: rect.left,
    x: rect.left,
    y: rect.top
  };
}

function getWindow(node) {
  if (node.toString() !== '[object Window]') {
    var ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView : window;
  }
  return node;
}

function getWindowScroll(node) {
  var win = getWindow(node);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft: scrollLeft,
    scrollTop: scrollTop
  };
}

function isElement(node) {
  var OwnElement = getWindow(node).Element;
  return node instanceof OwnElement || node instanceof Element;
}
function isHTMLElement(node) {
  var OwnElement = getWindow(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
}

function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}

function getNodeScroll(node) {
  if (node === getWindow(node) || !isHTMLElement(node)) {
    return getWindowScroll(node);
  } else {
    return getHTMLElementScroll(node);
  }
}

function getNodeName(element) {
  return element ? (element.nodeName || '').toLowerCase() : null;
}

function getDocumentElement(element) {
  return (isElement(element) ? element.ownerDocument : element.document).documentElement;
}

function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
}

function getComputedStyle$1(element) {
  return getWindow(element).getComputedStyle(element);
}

function isScrollParent(element) {
  var _getComputedStyle = getComputedStyle$1(element),
      overflow = _getComputedStyle.overflow,
      overflowX = _getComputedStyle.overflowX,
      overflowY = _getComputedStyle.overflowY;
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}

function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  var documentElement = getDocumentElement(offsetParent);
  var rect = getBoundingClientRect(elementOrVirtualElement);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };
  if (!isFixed) {
    if (getNodeName(offsetParent) !== 'body' ||
    isScrollParent(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      offsets = getBoundingClientRect(offsetParent);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}

function getLayoutRect(element) {
  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width: element.offsetWidth,
    height: element.offsetHeight
  };
}

function getParentNode(element) {
  if (getNodeName(element) === 'html') {
    return element;
  }
  return (
    element.assignedSlot ||
    element.parentNode ||
    element.host ||
    getDocumentElement(element)
  );
}

function getScrollParent(node) {
  if (['html', 'body', '#document'].indexOf(getNodeName(node)) >= 0) {
    return node.ownerDocument.body;
  }
  if (isHTMLElement(node) && isScrollParent(node)) {
    return node;
  }
  return getScrollParent(getParentNode(node));
}

function listScrollParents(element, list) {
  if (list === void 0) {
    list = [];
  }
  var scrollParent = getScrollParent(element);
  var isBody = getNodeName(scrollParent) === 'body';
  var win = getWindow(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList :
  updatedList.concat(listScrollParents(getParentNode(target)));
}

function isTableElement(element) {
  return ['table', 'td', 'th'].indexOf(getNodeName(element)) >= 0;
}

function getTrueOffsetParent(element) {
  if (!isHTMLElement(element) ||
  getComputedStyle$1(element).position === 'fixed') {
    return null;
  }
  return element.offsetParent;
}
function getOffsetParent(element) {
  var window = getWindow(element);
  var offsetParent = getTrueOffsetParent(element);
  while (offsetParent && isTableElement(offsetParent)) {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && getNodeName(offsetParent) === 'body' && getComputedStyle$1(offsetParent).position === 'static') {
    return window;
  }
  return offsetParent || window;
}

var top = 'top';
var bottom = 'bottom';
var right = 'right';
var left = 'left';
var auto = 'auto';
var basePlacements = [top, bottom, right, left];
var start = 'start';
var end = 'end';
var clippingParents = 'clippingParents';
var viewport = 'viewport';
var popper = 'popper';
var reference = 'reference';
var variationPlacements = basePlacements.reduce(function (acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements = [].concat(basePlacements, [auto]).reduce(function (acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []);
var beforeRead = 'beforeRead';
var read = 'read';
var afterRead = 'afterRead';
var beforeMain = 'beforeMain';
var main = 'main';
var afterMain = 'afterMain';
var beforeWrite = 'beforeWrite';
var write = 'write';
var afterWrite = 'afterWrite';
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

function order(modifiers) {
  var map = new Map();
  var visited = new Set();
  var result = [];
  modifiers.forEach(function (modifier) {
    map.set(modifier.name, modifier);
  });
  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function (dep) {
      if (!visited.has(dep)) {
        var depModifier = map.get(dep);
        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }
  modifiers.forEach(function (modifier) {
    if (!visited.has(modifier.name)) {
      sort(modifier);
    }
  });
  return result;
}
function orderModifiers(modifiers) {
  var orderedModifiers = order(modifiers);
  return modifierPhases.reduce(function (acc, phase) {
    return acc.concat(orderedModifiers.filter(function (modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}

function debounce(fn) {
  var pending;
  return function () {
    if (!pending) {
      pending = new Promise(function (resolve) {
        Promise.resolve().then(function () {
          pending = undefined;
          resolve(fn());
        });
      });
    }
    return pending;
  };
}

function format(str) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }
  return [].concat(args).reduce(function (p, c) {
    return p.replace(/%s/, c);
  }, str);
}

var INVALID_MODIFIER_ERROR = 'Popper: modifier "%s" provided an invalid %s property, expected %s but got %s';
var MISSING_DEPENDENCY_ERROR = 'Popper: modifier "%s" requires "%s", but "%s" modifier is not available';
var VALID_PROPERTIES = ['name', 'enabled', 'phase', 'fn', 'effect', 'requires', 'options'];
function validateModifiers(modifiers) {
  modifiers.forEach(function (modifier) {
    Object.keys(modifier).forEach(function (key) {
      switch (key) {
        case 'name':
          if (typeof modifier.name !== 'string') {
            console.error(format(INVALID_MODIFIER_ERROR, String(modifier.name), '"name"', '"string"', "\"" + String(modifier.name) + "\""));
          }
          break;
        case 'enabled':
          if (typeof modifier.enabled !== 'boolean') {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"enabled"', '"boolean"', "\"" + String(modifier.enabled) + "\""));
          }
        case 'phase':
          if (modifierPhases.indexOf(modifier.phase) < 0) {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"phase"', "either " + modifierPhases.join(', '), "\"" + String(modifier.phase) + "\""));
          }
          break;
        case 'fn':
          if (typeof modifier.fn !== 'function') {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"fn"', '"function"', "\"" + String(modifier.fn) + "\""));
          }
          break;
        case 'effect':
          if (typeof modifier.effect !== 'function') {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"effect"', '"function"', "\"" + String(modifier.fn) + "\""));
          }
          break;
        case 'requires':
          if (!Array.isArray(modifier.requires)) {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requires"', '"array"', "\"" + String(modifier.requires) + "\""));
          }
          break;
        case 'requiresIfExists':
          if (!Array.isArray(modifier.requiresIfExists)) {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requiresIfExists"', '"array"', "\"" + String(modifier.requiresIfExists) + "\""));
          }
          break;
        case 'options':
        case 'data':
          break;
        default:
          console.error("PopperJS: an invalid property has been provided to the \"" + modifier.name + "\" modifier, valid properties are " + VALID_PROPERTIES.map(function (s) {
            return "\"" + s + "\"";
          }).join(', ') + "; but \"" + key + "\" was provided.");
      }
      modifier.requires && modifier.requires.forEach(function (requirement) {
        if (modifiers.find(function (mod) {
          return mod.name === requirement;
        }) == null) {
          console.error(format(MISSING_DEPENDENCY_ERROR, String(modifier.name), requirement, requirement));
        }
      });
    });
  });
}

function uniqueBy(arr, fn) {
  var identifiers = new Set();
  return arr.filter(function (item) {
    var identifier = fn(item);
    if (!identifiers.has(identifier)) {
      identifiers.add(identifier);
      return true;
    }
  });
}

function getBasePlacement(placement) {
  return placement.split('-')[0];
}

function mergeByName(modifiers) {
  var merged = modifiers.reduce(function (merged, current) {
    var existing = merged[current.name];
    merged[current.name] = existing ? Object.assign({}, existing, {}, current, {
      options: Object.assign({}, existing.options, {}, current.options),
      data: Object.assign({}, existing.data, {}, current.data)
    }) : current;
    return merged;
  }, {});
  return Object.keys(merged).map(function (key) {
    return merged[key];
  });
}

var INVALID_ELEMENT_ERROR = 'Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.';
var INFINITE_LOOP_ERROR = 'Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.';
var DEFAULT_OPTIONS = {
  placement: 'bottom',
  modifiers: [],
  strategy: 'absolute'
};
function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return !args.some(function (element) {
    return !(element && typeof element.getBoundingClientRect === 'function');
  });
}
function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }
  var _generatorOptions = generatorOptions,
      _generatorOptions$def = _generatorOptions.defaultModifiers,
      defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,
      _generatorOptions$def2 = _generatorOptions.defaultOptions,
      defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper(reference, popper, options) {
    if (options === void 0) {
      options = defaultOptions;
    }
    var state = {
      placement: 'bottom',
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, {}, defaultOptions),
      modifiersData: {},
      elements: {
        reference: reference,
        popper: popper
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance = {
      state: state,
      setOptions: function setOptions(options) {
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions, {}, state.options, {}, options);
        state.scrollParents = {
          reference: isElement(reference) ? listScrollParents(reference) : reference.contextElement ? listScrollParents(reference.contextElement) : [],
          popper: listScrollParents(popper)
        };
        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers, state.options.modifiers)));
        state.orderedModifiers = orderedModifiers.filter(function (m) {
          return m.enabled;
        });
        if (process.env.NODE_ENV !== "production") {
          var modifiers = uniqueBy([].concat(orderedModifiers, state.options.modifiers), function (_ref) {
            var name = _ref.name;
            return name;
          });
          validateModifiers(modifiers);
          if (getBasePlacement(state.options.placement) === auto) {
            var flipModifier = state.orderedModifiers.find(function (_ref2) {
              var name = _ref2.name;
              return name === 'flip';
            });
            if (!flipModifier) {
              console.error(['Popper: "auto" placements require the "flip" modifier be', 'present and enabled to work.'].join(' '));
            }
          }
          var _getComputedStyle = getComputedStyle$1(popper),
              marginTop = _getComputedStyle.marginTop,
              marginRight = _getComputedStyle.marginRight,
              marginBottom = _getComputedStyle.marginBottom,
              marginLeft = _getComputedStyle.marginLeft;
          if ([marginTop, marginRight, marginBottom, marginLeft].some(function (margin) {
            return parseFloat(margin);
          })) {
            console.warn(['Popper: CSS "margin" styles cannot be used to apply padding', 'between the popper and its reference element or boundary.', 'To replicate margin, use the `offset` modifier, as well as', 'the `padding` option in the `preventOverflow` and `flip`', 'modifiers.'].join(' '));
          }
        }
        runModifierEffects();
        return instance.update();
      },
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }
        var _state$elements = state.elements,
            reference = _state$elements.reference,
            popper = _state$elements.popper;
        if (!areValidElements(reference, popper)) {
          if (process.env.NODE_ENV !== "production") {
            console.error(INVALID_ELEMENT_ERROR);
          }
          return;
        }
        state.rects = {
          reference: getCompositeRect(reference, getOffsetParent(popper), state.options.strategy === 'fixed'),
          popper: getLayoutRect(popper)
        };
        state.reset = false;
        state.placement = state.options.placement;
        state.orderedModifiers.forEach(function (modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        var __debug_loops__ = 0;
        for (var index = 0; index < state.orderedModifiers.length; index++) {
          if (process.env.NODE_ENV !== "production") {
            __debug_loops__ += 1;
            if (__debug_loops__ > 100) {
              console.error(INFINITE_LOOP_ERROR);
              break;
            }
          }
          if (state.reset === true) {
            state.reset = false;
            index = -1;
            continue;
          }
          var _state$orderedModifie = state.orderedModifiers[index],
              fn = _state$orderedModifie.fn,
              _state$orderedModifie2 = _state$orderedModifie.options,
              _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,
              name = _state$orderedModifie.name;
          if (typeof fn === 'function') {
            state = fn({
              state: state,
              options: _options,
              name: name,
              instance: instance
            }) || state;
          }
        }
      },
      update: debounce(function () {
        return new Promise(function (resolve) {
          instance.forceUpdate();
          resolve(state);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };
    if (!areValidElements(reference, popper)) {
      if (process.env.NODE_ENV !== "production") {
        console.error(INVALID_ELEMENT_ERROR);
      }
      return instance;
    }
    instance.setOptions(options).then(function (state) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state);
      }
    });
    function runModifierEffects() {
      state.orderedModifiers.forEach(function (_ref3) {
        var name = _ref3.name,
            _ref3$options = _ref3.options,
            options = _ref3$options === void 0 ? {} : _ref3$options,
            effect = _ref3.effect;
        if (typeof effect === 'function') {
          var cleanupFn = effect({
            state: state,
            name: name,
            instance: instance,
            options: options
          });
          var noopFn = function noopFn() {};
          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }
    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function (fn) {
        return fn();
      });
      effectCleanupFns = [];
    }
    return instance;
  };
}
var createPopper = popperGenerator();

var passive = {
  passive: true
};
function effect(_ref) {
  var state = _ref.state,
      instance = _ref.instance,
      options = _ref.options;
  var _options$scroll = options.scroll,
      scroll = _options$scroll === void 0 ? true : _options$scroll,
      _options$resize = options.resize,
      resize = _options$resize === void 0 ? true : _options$resize;
  var window = getWindow(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
  if (scroll) {
    scrollParents.forEach(function (scrollParent) {
      scrollParent.addEventListener('scroll', instance.update, passive);
    });
  }
  if (resize) {
    window.addEventListener('resize', instance.update, passive);
  }
  return function () {
    if (scroll) {
      scrollParents.forEach(function (scrollParent) {
        scrollParent.removeEventListener('scroll', instance.update, passive);
      });
    }
    if (resize) {
      window.removeEventListener('resize', instance.update, passive);
    }
  };
}
var eventListeners = {
  name: 'eventListeners',
  enabled: true,
  phase: 'write',
  fn: function fn() {},
  effect: effect,
  data: {}
};

function getVariation(placement) {
  return placement.split('-')[1];
}

function getMainAxisFromPlacement(placement) {
  return ['top', 'bottom'].indexOf(placement) >= 0 ? 'x' : 'y';
}

function computeOffsets(_ref) {
  var reference = _ref.reference,
      element = _ref.element,
      placement = _ref.placement;
  var basePlacement = placement ? getBasePlacement(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference.x + reference.width / 2 - element.width / 2;
  var commonY = reference.y + reference.height / 2 - element.height / 2;
  var offsets;
  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference.y - element.height
      };
      break;
    case bottom:
      offsets = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case right:
      offsets = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case left:
      offsets = {
        x: reference.x - element.width,
        y: commonY
      };
      break;
    default:
      offsets = {
        x: reference.x,
        y: reference.y
      };
  }
  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
  if (mainAxis != null) {
    var len = mainAxis === 'y' ? 'height' : 'width';
    switch (variation) {
      case start:
        offsets[mainAxis] = Math.floor(offsets[mainAxis]) - Math.floor(reference[len] / 2 - element[len] / 2);
        break;
      case end:
        offsets[mainAxis] = Math.floor(offsets[mainAxis]) + Math.ceil(reference[len] / 2 - element[len] / 2);
        break;
    }
  }
  return offsets;
}

function popperOffsets(_ref) {
  var state = _ref.state,
      name = _ref.name;
  state.modifiersData[name] = computeOffsets({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: 'absolute',
    placement: state.placement
  });
}
var popperOffsets$1 = {
  name: 'popperOffsets',
  enabled: true,
  phase: 'read',
  fn: popperOffsets,
  data: {}
};

var unsetSides = {
  top: 'auto',
  right: 'auto',
  bottom: 'auto',
  left: 'auto'
};
function roundOffsets(_ref) {
  var x = _ref.x,
      y = _ref.y;
  var win = window;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: Math.round(x * dpr) / dpr || 0,
    y: Math.round(y * dpr) / dpr || 0
  };
}
function mapToStyles(_ref2) {
  var _Object$assign2;
  var popper = _ref2.popper,
      popperRect = _ref2.popperRect,
      placement = _ref2.placement,
      offsets = _ref2.offsets,
      position = _ref2.position,
      gpuAcceleration = _ref2.gpuAcceleration,
      adaptive = _ref2.adaptive;
  var _roundOffsets = roundOffsets(offsets),
      x = _roundOffsets.x,
      y = _roundOffsets.y;
  var hasX = offsets.hasOwnProperty('x');
  var hasY = offsets.hasOwnProperty('y');
  var sideX = left;
  var sideY = top;
  var win = window;
  if (adaptive) {
    var offsetParent = getOffsetParent(popper);
    if (offsetParent === getWindow(popper)) {
      offsetParent = getDocumentElement(popper);
    }
    if (placement === top) {
      sideY = bottom;
      y -= offsetParent.clientHeight - popperRect.height;
      y *= gpuAcceleration ? 1 : -1;
    }
    if (placement === left) {
      sideX = right;
      x -= offsetParent.clientWidth - popperRect.width;
      x *= gpuAcceleration ? 1 : -1;
    }
  }
  var commonStyles = Object.assign({
    position: position
  }, adaptive && unsetSides);
  if (gpuAcceleration) {
    var _Object$assign;
    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? '0' : '', _Object$assign[sideX] = hasX ? '0' : '', _Object$assign.transform = (win.devicePixelRatio || 1) < 2 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
  }
  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : '', _Object$assign2[sideX] = hasX ? x + "px" : '', _Object$assign2.transform = '', _Object$assign2));
}
function computeStyles(_ref3) {
  var state = _ref3.state,
      options = _ref3.options;
  var _options$gpuAccelerat = options.gpuAcceleration,
      gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,
      _options$adaptive = options.adaptive,
      adaptive = _options$adaptive === void 0 ? true : _options$adaptive;
  if (process.env.NODE_ENV !== "production") {
    var transitionProperty = getComputedStyle$1(state.elements.popper).transitionProperty || '';
    if (adaptive && ['transform', 'top', 'right', 'bottom', 'left'].some(function (property) {
      return transitionProperty.indexOf(property) >= 0;
    })) {
      console.warn(['Popper: Detected CSS transitions on at least one of the following', 'CSS properties: "transform", "top", "right", "bottom", "left".', '\n\n', 'Disable the "computeStyles" modifier\'s `adaptive` option to allow', 'for smooth transitions, or remove these properties from the CSS', 'transition declaration on the popper element if only transitioning', 'opacity or background-color for example.', '\n\n', 'We recommend using the popper element as a wrapper around an inner', 'element that can have any CSS property transitioned for animations.'].join(' '));
    }
  }
  var commonStyles = {
    placement: getBasePlacement(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration: gpuAcceleration
  };
  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, {}, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive: adaptive
    })));
  }
  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, {}, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: 'absolute',
      adaptive: false
    })));
  }
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    'data-popper-placement': state.placement
  });
}
var computeStyles$1 = {
  name: 'computeStyles',
  enabled: true,
  phase: 'beforeWrite',
  fn: computeStyles,
  data: {}
};

function applyStyles(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function (name) {
    var style = state.styles[name] || {};
    var attributes = state.attributes[name] || {};
    var element = state.elements[name];
    if (!isHTMLElement(element) || !getNodeName(element)) {
      return;
    }
    Object.assign(element.style, style);
    Object.keys(attributes).forEach(function (name) {
      var value = attributes[name];
      if (value === false) {
        element.removeAttribute(name);
      } else {
        element.setAttribute(name, value === true ? '' : value);
      }
    });
  });
}
function effect$1(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: '0',
      top: '0',
      margin: '0'
    },
    arrow: {
      position: 'absolute'
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }
  return function () {
    Object.keys(state.elements).forEach(function (name) {
      var element = state.elements[name];
      var attributes = state.attributes[name] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
      var style = styleProperties.reduce(function (style, property) {
        style[property] = '';
        return style;
      }, {});
      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      }
      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function (attribute) {
        element.removeAttribute(attribute);
      });
    });
  };
}
var applyStyles$1 = {
  name: 'applyStyles',
  enabled: true,
  phase: 'write',
  fn: applyStyles,
  effect: effect$1,
  requires: ['computeStyles']
};

function distanceAndSkiddingToXY(placement, rects, offset) {
  var basePlacement = getBasePlacement(placement);
  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
  var _ref = typeof offset === 'function' ? offset(Object.assign({}, rects, {
    placement: placement
  })) : offset,
      skidding = _ref[0],
      distance = _ref[1];
  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}
function offset(_ref2) {
  var state = _ref2.state,
      options = _ref2.options,
      name = _ref2.name;
  var _options$offset = options.offset,
      offset = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = placements.reduce(function (acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement],
      x = _data$state$placement.x,
      y = _data$state$placement.y;
  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x;
    state.modifiersData.popperOffsets.y += y;
  }
  state.modifiersData[name] = data;
}
var offset$1 = {
  name: 'offset',
  enabled: true,
  phase: 'main',
  requires: ['popperOffsets'],
  fn: offset
};

var hash = {
  left: 'right',
  right: 'left',
  bottom: 'top',
  top: 'bottom'
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function (matched) {
    return hash[matched];
  });
}

var hash$1 = {
  start: 'end',
  end: 'start'
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function (matched) {
    return hash$1[matched];
  });
}

function getViewportRect(element) {
  var win = getWindow(element);
  var visualViewport = win.visualViewport;
  var width = win.innerWidth;
  var height = win.innerHeight;
  if (visualViewport && /iPhone|iPod|iPad/.test(navigator.platform)) {
    width = visualViewport.width;
    height = visualViewport.height;
  }
  return {
    width: width,
    height: height,
    x: 0,
    y: 0
  };
}

function getDocumentRect(element) {
  var win = getWindow(element);
  var winScroll = getWindowScroll(element);
  var documentRect = getCompositeRect(getDocumentElement(element), win);
  documentRect.height = Math.max(documentRect.height, win.innerHeight);
  documentRect.width = Math.max(documentRect.width, win.innerWidth);
  documentRect.x = -winScroll.scrollLeft;
  documentRect.y = -winScroll.scrollTop;
  return documentRect;
}

function toNumber(cssValue) {
  return parseFloat(cssValue) || 0;
}
function getBorders(element) {
  var computedStyle = isHTMLElement(element) ? getComputedStyle$1(element) : {};
  return {
    top: toNumber(computedStyle.borderTopWidth),
    right: toNumber(computedStyle.borderRightWidth),
    bottom: toNumber(computedStyle.borderBottomWidth),
    left: toNumber(computedStyle.borderLeftWidth)
  };
}

function getDecorations(element) {
  var win = getWindow(element);
  var borders = getBorders(element);
  var isHTML = getNodeName(element) === 'html';
  var winScrollBarX = getWindowScrollBarX(element);
  var x = element.clientWidth + borders.right;
  var y = element.clientHeight + borders.bottom;
  if (isHTML && win.innerHeight - element.clientHeight > 50) {
    y = win.innerHeight - borders.bottom;
  }
  return {
    top: isHTML ? 0 : element.clientTop,
    right:
    element.clientLeft > borders.left ? borders.right :
    isHTML ? win.innerWidth - x - winScrollBarX : element.offsetWidth - x,
    bottom: isHTML ? win.innerHeight - y : element.offsetHeight - y,
    left: isHTML ? winScrollBarX : element.clientLeft
  };
}

function contains(parent, child) {
  var isShadow = Boolean(child.getRootNode && child.getRootNode().host);
  if (parent.contains(child)) {
    return true;
  }
  else if (isShadow) {
      var next = child;
      do {
        if (next && parent.isSameNode(next)) {
          return true;
        }
        next = next.parentNode || next.host;
      } while (next);
    }
  return false;
}

function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}

function getClientRectFromMixedType(element, clippingParent) {
  return clippingParent === viewport ? rectToClientRect(getViewportRect(element)) : isHTMLElement(clippingParent) ? getBoundingClientRect(clippingParent) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
}
function getClippingParents(element) {
  var clippingParents = listScrollParents(element);
  var canEscapeClipping = ['absolute', 'fixed'].indexOf(getComputedStyle$1(element).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
  if (!isElement(clipperElement)) {
    return [];
  }
  return clippingParents.filter(function (clippingParent) {
    return isElement(clippingParent) && contains(clippingParent, clipperElement);
  });
}
function getClippingRect(element, boundary, rootBoundary) {
  var mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);
  var clippingParents = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents[0];
  var clippingRect = clippingParents.reduce(function (accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element, clippingParent);
    var decorations = getDecorations(isHTMLElement(clippingParent) ? clippingParent : getDocumentElement(element));
    accRect.top = Math.max(rect.top + decorations.top, accRect.top);
    accRect.right = Math.min(rect.right - decorations.right, accRect.right);
    accRect.bottom = Math.min(rect.bottom - decorations.bottom, accRect.bottom);
    accRect.left = Math.max(rect.left + decorations.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}

function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}

function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), {}, paddingObject);
}

function expandToHashMap(value, keys) {
  return keys.reduce(function (hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}

function detectOverflow(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options,
      _options$placement = _options.placement,
      placement = _options$placement === void 0 ? state.placement : _options$placement,
      _options$boundary = _options.boundary,
      boundary = _options$boundary === void 0 ? clippingParents : _options$boundary,
      _options$rootBoundary = _options.rootBoundary,
      rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary,
      _options$elementConte = _options.elementContext,
      elementContext = _options$elementConte === void 0 ? popper : _options$elementConte,
      _options$altBoundary = _options.altBoundary,
      altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,
      _options$padding = _options.padding,
      padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));
  var altContext = elementContext === popper ? reference : popper;
  var referenceElement = state.elements.reference;
  var popperRect = state.rects.popper;
  var element = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary);
  var referenceClientRect = getBoundingClientRect(referenceElement);
  var popperOffsets = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    strategy: 'absolute',
    placement: placement
  });
  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, {}, popperOffsets));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset;
  if (elementContext === popper && offsetData) {
    var offset = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function (key) {
      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [top, bottom].indexOf(key) >= 0 ? 'y' : 'x';
      overflowOffsets[key] += offset[axis] * multiply;
    });
  }
  return overflowOffsets;
}

function computeAutoPlacement(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options,
      placement = _options.placement,
      boundary = _options.boundary,
      rootBoundary = _options.rootBoundary,
      padding = _options.padding,
      flipVariations = _options.flipVariations,
      _options$allowedAutoP = _options.allowedAutoPlacements,
      allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements$1 = (variation ? flipVariations ? variationPlacements : variationPlacements.filter(function (placement) {
    return getVariation(placement) === variation;
  }) : basePlacements).filter(function (placement) {
    return allowedAutoPlacements.indexOf(placement) >= 0;
  });
  var overflows = placements$1.reduce(function (acc, placement) {
    acc[placement] = detectOverflow(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      padding: padding
    })[getBasePlacement(placement)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function (a, b) {
    return overflows[a] - overflows[b];
  });
}

function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement(placement) === auto) {
    return [];
  }
  var oppositePlacement = getOppositePlacement(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}
function flip(_ref) {
  var state = _ref.state,
      options = _ref.options,
      name = _ref.name;
  if (state.modifiersData[name]._skip) {
    return;
  }
  var _options$mainAxis = options.mainAxis,
      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
      _options$altAxis = options.altAxis,
      checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis,
      specifiedFallbackPlacements = options.fallbackPlacements,
      padding = options.padding,
      boundary = options.boundary,
      rootBoundary = options.rootBoundary,
      altBoundary = options.altBoundary,
      _options$flipVariatio = options.flipVariations,
      flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,
      allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = getBasePlacement(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements = [preferredPlacement].concat(fallbackPlacements).reduce(function (acc, placement) {
    return acc.concat(getBasePlacement(placement) === auto ? computeAutoPlacement(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      padding: padding,
      flipVariations: flipVariations,
      allowedAutoPlacements: allowedAutoPlacements
    }) : placement);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements[0];
  for (var i = 0; i < placements.length; i++) {
    var placement = placements[i];
    var _basePlacement = getBasePlacement(placement);
    var isStartVariation = getVariation(placement) === start;
    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? 'width' : 'height';
    var overflow = detectOverflow(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      altBoundary: altBoundary,
      padding: padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }
    var altVariationSide = getOppositePlacement(mainVariationSide);
    var checks = [];
    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }
    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }
    if (checks.every(function (check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }
    checksMap.set(placement, checks);
  }
  if (makeFallbackChecks) {
    var numberOfChecks = flipVariations ? 3 : 1;
    var _loop = function _loop(_i) {
      var fittingPlacement = placements.find(function (placement) {
        var checks = checksMap.get(placement);
        if (checks) {
          return checks.slice(0, _i).every(function (check) {
            return check;
          });
        }
      });
      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };
    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);
      if (_ret === "break") break;
    }
  }
  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
}
var flip$1 = {
  name: 'flip',
  enabled: true,
  phase: 'main',
  fn: flip,
  requiresIfExists: ['offset'],
  data: {
    _skip: false
  }
};

function getAltAxis(axis) {
  return axis === 'x' ? 'y' : 'x';
}

function within(min, value, max) {
  return Math.max(min, Math.min(value, max));
}

function preventOverflow(_ref) {
  var state = _ref.state,
      options = _ref.options,
      name = _ref.name;
  var _options$mainAxis = options.mainAxis,
      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
      _options$altAxis = options.altAxis,
      checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,
      boundary = options.boundary,
      rootBoundary = options.rootBoundary,
      altBoundary = options.altBoundary,
      padding = options.padding,
      _options$tether = options.tether,
      tether = _options$tether === void 0 ? true : _options$tether,
      _options$tetherOffset = options.tetherOffset,
      tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = detectOverflow(state, {
    boundary: boundary,
    rootBoundary: rootBoundary,
    padding: padding,
    altBoundary: altBoundary
  });
  var basePlacement = getBasePlacement(state.placement);
  var variation = getVariation(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var data = {
    x: 0,
    y: 0
  };
  if (!popperOffsets) {
    return;
  }
  if (checkMainAxis) {
    var mainSide = mainAxis === 'y' ? top : left;
    var altSide = mainAxis === 'y' ? bottom : right;
    var len = mainAxis === 'y' ? 'height' : 'width';
    var offset = popperOffsets[mainAxis];
    var min = popperOffsets[mainAxis] + overflow[mainSide];
    var max = popperOffsets[mainAxis] - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide];
    var arrowLen = within(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - tetherOffsetValue : minLen - arrowLen - arrowPaddingMin - tetherOffsetValue;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + tetherOffsetValue : maxLen + arrowLen + arrowPaddingMax + tetherOffsetValue;
    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === 'y' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = state.modifiersData.offset ? state.modifiersData.offset[state.placement][mainAxis] : 0;
    var tetherMin = popperOffsets[mainAxis] + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = popperOffsets[mainAxis] + maxOffset - offsetModifierValue;
    var preventedOffset = within(tether ? Math.min(min, tetherMin) : min, offset, tether ? Math.max(max, tetherMax) : max);
    popperOffsets[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset;
  }
  if (checkAltAxis) {
    var _mainSide = mainAxis === 'x' ? top : left;
    var _altSide = mainAxis === 'x' ? bottom : right;
    var _offset = popperOffsets[altAxis];
    var _min = _offset + overflow[_mainSide];
    var _max = _offset - overflow[_altSide];
    var _preventedOffset = within(_min, _offset, _max);
    popperOffsets[altAxis] = _preventedOffset;
    data[altAxis] = _preventedOffset - _offset;
  }
  state.modifiersData[name] = data;
}
var preventOverflow$1 = {
  name: 'preventOverflow',
  enabled: true,
  phase: 'main',
  fn: preventOverflow,
  requiresIfExists: ['offset']
};

function arrow(_ref) {
  var _state$modifiersData$;
  var state = _ref.state,
      name = _ref.name;
  var arrowElement = state.elements.arrow;
  var popperOffsets = state.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement(state.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left, right].indexOf(basePlacement) >= 0;
  var len = isVertical ? 'height' : 'width';
  if (!arrowElement || !popperOffsets) {
    return;
  }
  var paddingObject = state.modifiersData[name + "#persistent"].padding;
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === 'y' ? top : left;
  var maxProp = axis === 'y' ? bottom : right;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];
  var startDiff = popperOffsets[axis] - state.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent(arrowElement);
  var clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2;
  var min = paddingObject[minProp];
  var max = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset = within(min, center, max);
  var axisProp = axis;
  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);
}
function effect$2(_ref2) {
  var state = _ref2.state,
      options = _ref2.options,
      name = _ref2.name;
  var _options$element = options.element,
      arrowElement = _options$element === void 0 ? '[data-popper-arrow]' : _options$element,
      _options$padding = options.padding,
      padding = _options$padding === void 0 ? 0 : _options$padding;
  if (arrowElement == null) {
    return;
  }
  if (typeof arrowElement === 'string') {
    arrowElement = state.elements.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return;
    }
  }
  if (process.env.NODE_ENV !== "production") {
    if (!isHTMLElement(arrowElement)) {
      console.error(['Popper: "arrow" element must be an HTMLElement (not an SVGElement).', 'To use an SVG arrow, wrap it in an HTMLElement that will be used as', 'the arrow.'].join(' '));
    }
  }
  if (!contains(state.elements.popper, arrowElement)) {
    if (process.env.NODE_ENV !== "production") {
      console.error(['Popper: "arrow" modifier\'s `element` must be a child of the popper', 'element.'].join(' '));
    }
    return;
  }
  state.elements.arrow = arrowElement;
  state.modifiersData[name + "#persistent"] = {
    padding: mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements))
  };
}
var arrow$1 = {
  name: 'arrow',
  enabled: true,
  phase: 'main',
  fn: arrow,
  effect: effect$2,
  requires: ['popperOffsets'],
  requiresIfExists: ['preventOverflow']
};

function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }
  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}
function isAnySideFullyClipped(overflow) {
  return [top, right, bottom, left].some(function (side) {
    return overflow[side] >= 0;
  });
}
function hide(_ref) {
  var state = _ref.state,
      name = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow(state, {
    elementContext: 'reference'
  });
  var popperAltOverflow = detectOverflow(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets: referenceClippingOffsets,
    popperEscapeOffsets: popperEscapeOffsets,
    isReferenceHidden: isReferenceHidden,
    hasPopperEscaped: hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    'data-popper-reference-hidden': isReferenceHidden,
    'data-popper-escaped': hasPopperEscaped
  });
}
var hide$1 = {
  name: 'hide',
  enabled: true,
  phase: 'main',
  requiresIfExists: ['preventOverflow'],
  fn: hide
};

var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1];
var createPopper$1 = popperGenerator({
  defaultModifiers: defaultModifiers
});

var script$4 = {
  name: 'APopper',
  props: {
    value: {
      type: Boolean,
      "default": false
    },
    reference: {
      required: true
    }
  },
  setup: function setup(props) {
    var zIndex = ref(0);
    var popper = ref(null);
    var showPopper = ref(props.value);
    onMounted(function () {
      var popperInstance = null;
      var isRendering = false;
      var queue = [];
      watchEffect(function () {
        if (props.value === false) {
          if (isRendering) {
            queue.push('close');
            return;
          }
          handleClose();
        } else if (props.value === true) {
          if (isRendering) {
            queue.push('open');
            return;
          }
          handleOpen();
        }
      });
      function viewQueue() {
        if (!queue.length) return;
        var lastTask = queue[queue.length - 1];
        if (lastTask === 'close') handleClose();else if (lastTask === 'open') handleOpen();
        queue.splice(0);
      }
      function handleClose() {
        if (popperInstance !== null) {
          isRendering = true;
          showPopper.value = false;
          setTimeout(function () {
            popperInstance.destroy();
            popperInstance = null;
            isRendering = false;
            viewQueue();
          }, 220);
        }
      }
      function handleOpen() {
        var _props$reference$$el;
        isRendering = true;
        showPopper.value = true;
        var reference = (_props$reference$$el = props.reference.$el) !== null && _props$reference$$el !== void 0 ? _props$reference$$el : props.reference;
        popperInstance = createPopper$1(reference, popper.value, {
          placement: 'bottom-start',
          modifiers: [{
            name: 'offset',
            options: {
              offset: [0, 8]
            }
          }],
          strategy: 'fixed'
        });
        zIndex.value = stackManager.nextStack();
        setTimeout(function () {
          isRendering = false;
          viewQueue();
        }, 220);
      }
    });
    return {
      zIndex: zIndex,
      popper: popper,
      showPopper: showPopper
    };
  }
};

const _hoisted_1$2 = { class: "a-popper-container" };

function render$4(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createBlock("div", {
    ref: "popper",
    class: "a-popper",
    style: { zIndex: _ctx.zIndex },
    onClick: _cache[1] || (_cache[1] = withModifiers(() => {}, ["stop"]))
  }, [
    createVNode(Transition, { name: "drop" }, {
      default: withCtx(() => [
        withDirectives(createVNode("div", _hoisted_1$2, [
          renderSlot(_ctx.$slots, "default")
        ], 512 /* NEED_PATCH */), [
          [vShow, _ctx.showPopper]
        ])
      ]),
      _: 3
    })
  ], 4 /* STYLE */))
}

script$4.render = render$4;
script$4.__file = "src/components/popper/popper.vue";

function createCommonjsModule(fn, basedir, module) {
	return module = {
	  path: basedir,
	  exports: {},
	  require: function (path, base) {
      return commonjsRequire(path, (base === undefined || base === null) ? module.path : base);
    }
	}, fn(module, module.exports), module.exports;
}

function commonjsRequire () {
	throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
}

var tinycolor = createCommonjsModule(function (module) {
(function(Math) {
var trimLeft = /^\s+/,
    trimRight = /\s+$/,
    tinyCounter = 0,
    mathRound = Math.round,
    mathMin = Math.min,
    mathMax = Math.max,
    mathRandom = Math.random;
function tinycolor (color, opts) {
    color = (color) ? color : '';
    opts = opts || { };
    if (color instanceof tinycolor) {
       return color;
    }
    if (!(this instanceof tinycolor)) {
        return new tinycolor(color, opts);
    }
    var rgb = inputToRGB(color);
    this._originalInput = color,
    this._r = rgb.r,
    this._g = rgb.g,
    this._b = rgb.b,
    this._a = rgb.a,
    this._roundA = mathRound(100*this._a) / 100,
    this._format = opts.format || rgb.format;
    this._gradientType = opts.gradientType;
    if (this._r < 1) { this._r = mathRound(this._r); }
    if (this._g < 1) { this._g = mathRound(this._g); }
    if (this._b < 1) { this._b = mathRound(this._b); }
    this._ok = rgb.ok;
    this._tc_id = tinyCounter++;
}
tinycolor.prototype = {
    isDark: function() {
        return this.getBrightness() < 128;
    },
    isLight: function() {
        return !this.isDark();
    },
    isValid: function() {
        return this._ok;
    },
    getOriginalInput: function() {
      return this._originalInput;
    },
    getFormat: function() {
        return this._format;
    },
    getAlpha: function() {
        return this._a;
    },
    getBrightness: function() {
        var rgb = this.toRgb();
        return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1000;
    },
    getLuminance: function() {
        var rgb = this.toRgb();
        var RsRGB, GsRGB, BsRGB, R, G, B;
        RsRGB = rgb.r/255;
        GsRGB = rgb.g/255;
        BsRGB = rgb.b/255;
        if (RsRGB <= 0.03928) {R = RsRGB / 12.92;} else {R = Math.pow(((RsRGB + 0.055) / 1.055), 2.4);}
        if (GsRGB <= 0.03928) {G = GsRGB / 12.92;} else {G = Math.pow(((GsRGB + 0.055) / 1.055), 2.4);}
        if (BsRGB <= 0.03928) {B = BsRGB / 12.92;} else {B = Math.pow(((BsRGB + 0.055) / 1.055), 2.4);}
        return (0.2126 * R) + (0.7152 * G) + (0.0722 * B);
    },
    setAlpha: function(value) {
        this._a = boundAlpha(value);
        this._roundA = mathRound(100*this._a) / 100;
        return this;
    },
    toHsv: function() {
        var hsv = rgbToHsv(this._r, this._g, this._b);
        return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: this._a };
    },
    toHsvString: function() {
        var hsv = rgbToHsv(this._r, this._g, this._b);
        var h = mathRound(hsv.h * 360), s = mathRound(hsv.s * 100), v = mathRound(hsv.v * 100);
        return (this._a == 1) ?
          "hsv("  + h + ", " + s + "%, " + v + "%)" :
          "hsva(" + h + ", " + s + "%, " + v + "%, "+ this._roundA + ")";
    },
    toHsl: function() {
        var hsl = rgbToHsl(this._r, this._g, this._b);
        return { h: hsl.h * 360, s: hsl.s, l: hsl.l, a: this._a };
    },
    toHslString: function() {
        var hsl = rgbToHsl(this._r, this._g, this._b);
        var h = mathRound(hsl.h * 360), s = mathRound(hsl.s * 100), l = mathRound(hsl.l * 100);
        return (this._a == 1) ?
          "hsl("  + h + ", " + s + "%, " + l + "%)" :
          "hsla(" + h + ", " + s + "%, " + l + "%, "+ this._roundA + ")";
    },
    toHex: function(allow3Char) {
        return rgbToHex(this._r, this._g, this._b, allow3Char);
    },
    toHexString: function(allow3Char) {
        return '#' + this.toHex(allow3Char);
    },
    toHex8: function(allow4Char) {
        return rgbaToHex(this._r, this._g, this._b, this._a, allow4Char);
    },
    toHex8String: function(allow4Char) {
        return '#' + this.toHex8(allow4Char);
    },
    toRgb: function() {
        return { r: mathRound(this._r), g: mathRound(this._g), b: mathRound(this._b), a: this._a };
    },
    toRgbString: function() {
        return (this._a == 1) ?
          "rgb("  + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ")" :
          "rgba(" + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ", " + this._roundA + ")";
    },
    toPercentageRgb: function() {
        return { r: mathRound(bound01(this._r, 255) * 100) + "%", g: mathRound(bound01(this._g, 255) * 100) + "%", b: mathRound(bound01(this._b, 255) * 100) + "%", a: this._a };
    },
    toPercentageRgbString: function() {
        return (this._a == 1) ?
          "rgb("  + mathRound(bound01(this._r, 255) * 100) + "%, " + mathRound(bound01(this._g, 255) * 100) + "%, " + mathRound(bound01(this._b, 255) * 100) + "%)" :
          "rgba(" + mathRound(bound01(this._r, 255) * 100) + "%, " + mathRound(bound01(this._g, 255) * 100) + "%, " + mathRound(bound01(this._b, 255) * 100) + "%, " + this._roundA + ")";
    },
    toName: function() {
        if (this._a === 0) {
            return "transparent";
        }
        if (this._a < 1) {
            return false;
        }
        return hexNames[rgbToHex(this._r, this._g, this._b, true)] || false;
    },
    toFilter: function(secondColor) {
        var hex8String = '#' + rgbaToArgbHex(this._r, this._g, this._b, this._a);
        var secondHex8String = hex8String;
        var gradientType = this._gradientType ? "GradientType = 1, " : "";
        if (secondColor) {
            var s = tinycolor(secondColor);
            secondHex8String = '#' + rgbaToArgbHex(s._r, s._g, s._b, s._a);
        }
        return "progid:DXImageTransform.Microsoft.gradient("+gradientType+"startColorstr="+hex8String+",endColorstr="+secondHex8String+")";
    },
    toString: function(format) {
        var formatSet = !!format;
        format = format || this._format;
        var formattedString = false;
        var hasAlpha = this._a < 1 && this._a >= 0;
        var needsAlphaFormat = !formatSet && hasAlpha && (format === "hex" || format === "hex6" || format === "hex3" || format === "hex4" || format === "hex8" || format === "name");
        if (needsAlphaFormat) {
            if (format === "name" && this._a === 0) {
                return this.toName();
            }
            return this.toRgbString();
        }
        if (format === "rgb") {
            formattedString = this.toRgbString();
        }
        if (format === "prgb") {
            formattedString = this.toPercentageRgbString();
        }
        if (format === "hex" || format === "hex6") {
            formattedString = this.toHexString();
        }
        if (format === "hex3") {
            formattedString = this.toHexString(true);
        }
        if (format === "hex4") {
            formattedString = this.toHex8String(true);
        }
        if (format === "hex8") {
            formattedString = this.toHex8String();
        }
        if (format === "name") {
            formattedString = this.toName();
        }
        if (format === "hsl") {
            formattedString = this.toHslString();
        }
        if (format === "hsv") {
            formattedString = this.toHsvString();
        }
        return formattedString || this.toHexString();
    },
    clone: function() {
        return tinycolor(this.toString());
    },
    _applyModification: function(fn, args) {
        var color = fn.apply(null, [this].concat([].slice.call(args)));
        this._r = color._r;
        this._g = color._g;
        this._b = color._b;
        this.setAlpha(color._a);
        return this;
    },
    lighten: function() {
        return this._applyModification(lighten, arguments);
    },
    brighten: function() {
        return this._applyModification(brighten, arguments);
    },
    darken: function() {
        return this._applyModification(darken, arguments);
    },
    desaturate: function() {
        return this._applyModification(desaturate, arguments);
    },
    saturate: function() {
        return this._applyModification(saturate, arguments);
    },
    greyscale: function() {
        return this._applyModification(greyscale, arguments);
    },
    spin: function() {
        return this._applyModification(spin, arguments);
    },
    _applyCombination: function(fn, args) {
        return fn.apply(null, [this].concat([].slice.call(args)));
    },
    analogous: function() {
        return this._applyCombination(analogous, arguments);
    },
    complement: function() {
        return this._applyCombination(complement, arguments);
    },
    monochromatic: function() {
        return this._applyCombination(monochromatic, arguments);
    },
    splitcomplement: function() {
        return this._applyCombination(splitcomplement, arguments);
    },
    triad: function() {
        return this._applyCombination(triad, arguments);
    },
    tetrad: function() {
        return this._applyCombination(tetrad, arguments);
    }
};
tinycolor.fromRatio = function(color, opts) {
    if (typeof color == "object") {
        var newColor = {};
        for (var i in color) {
            if (color.hasOwnProperty(i)) {
                if (i === "a") {
                    newColor[i] = color[i];
                }
                else {
                    newColor[i] = convertToPercentage(color[i]);
                }
            }
        }
        color = newColor;
    }
    return tinycolor(color, opts);
};
function inputToRGB(color) {
    var rgb = { r: 0, g: 0, b: 0 };
    var a = 1;
    var s = null;
    var v = null;
    var l = null;
    var ok = false;
    var format = false;
    if (typeof color == "string") {
        color = stringInputToObject(color);
    }
    if (typeof color == "object") {
        if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {
            rgb = rgbToRgb(color.r, color.g, color.b);
            ok = true;
            format = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
        }
        else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {
            s = convertToPercentage(color.s);
            v = convertToPercentage(color.v);
            rgb = hsvToRgb(color.h, s, v);
            ok = true;
            format = "hsv";
        }
        else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {
            s = convertToPercentage(color.s);
            l = convertToPercentage(color.l);
            rgb = hslToRgb(color.h, s, l);
            ok = true;
            format = "hsl";
        }
        if (color.hasOwnProperty("a")) {
            a = color.a;
        }
    }
    a = boundAlpha(a);
    return {
        ok: ok,
        format: color.format || format,
        r: mathMin(255, mathMax(rgb.r, 0)),
        g: mathMin(255, mathMax(rgb.g, 0)),
        b: mathMin(255, mathMax(rgb.b, 0)),
        a: a
    };
}
function rgbToRgb(r, g, b){
    return {
        r: bound01(r, 255) * 255,
        g: bound01(g, 255) * 255,
        b: bound01(b, 255) * 255
    };
}
function rgbToHsl(r, g, b) {
    r = bound01(r, 255);
    g = bound01(g, 255);
    b = bound01(b, 255);
    var max = mathMax(r, g, b), min = mathMin(r, g, b);
    var h, s, l = (max + min) / 2;
    if(max == min) {
        h = s = 0;
    }
    else {
        var d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch(max) {
            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
        }
        h /= 6;
    }
    return { h: h, s: s, l: l };
}
function hslToRgb(h, s, l) {
    var r, g, b;
    h = bound01(h, 360);
    s = bound01(s, 100);
    l = bound01(l, 100);
    function hue2rgb(p, q, t) {
        if(t < 0) t += 1;
        if(t > 1) t -= 1;
        if(t < 1/6) return p + (q - p) * 6 * t;
        if(t < 1/2) return q;
        if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;
        return p;
    }
    if(s === 0) {
        r = g = b = l;
    }
    else {
        var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        var p = 2 * l - q;
        r = hue2rgb(p, q, h + 1/3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1/3);
    }
    return { r: r * 255, g: g * 255, b: b * 255 };
}
function rgbToHsv(r, g, b) {
    r = bound01(r, 255);
    g = bound01(g, 255);
    b = bound01(b, 255);
    var max = mathMax(r, g, b), min = mathMin(r, g, b);
    var h, s, v = max;
    var d = max - min;
    s = max === 0 ? 0 : d / max;
    if(max == min) {
        h = 0;
    }
    else {
        switch(max) {
            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
        }
        h /= 6;
    }
    return { h: h, s: s, v: v };
}
 function hsvToRgb(h, s, v) {
    h = bound01(h, 360) * 6;
    s = bound01(s, 100);
    v = bound01(v, 100);
    var i = Math.floor(h),
        f = h - i,
        p = v * (1 - s),
        q = v * (1 - f * s),
        t = v * (1 - (1 - f) * s),
        mod = i % 6,
        r = [v, q, p, p, t, v][mod],
        g = [t, v, v, q, p, p][mod],
        b = [p, p, t, v, v, q][mod];
    return { r: r * 255, g: g * 255, b: b * 255 };
}
function rgbToHex(r, g, b, allow3Char) {
    var hex = [
        pad2(mathRound(r).toString(16)),
        pad2(mathRound(g).toString(16)),
        pad2(mathRound(b).toString(16))
    ];
    if (allow3Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1)) {
        return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
    }
    return hex.join("");
}
function rgbaToHex(r, g, b, a, allow4Char) {
    var hex = [
        pad2(mathRound(r).toString(16)),
        pad2(mathRound(g).toString(16)),
        pad2(mathRound(b).toString(16)),
        pad2(convertDecimalToHex(a))
    ];
    if (allow4Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1) && hex[3].charAt(0) == hex[3].charAt(1)) {
        return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);
    }
    return hex.join("");
}
function rgbaToArgbHex(r, g, b, a) {
    var hex = [
        pad2(convertDecimalToHex(a)),
        pad2(mathRound(r).toString(16)),
        pad2(mathRound(g).toString(16)),
        pad2(mathRound(b).toString(16))
    ];
    return hex.join("");
}
tinycolor.equals = function (color1, color2) {
    if (!color1 || !color2) { return false; }
    return tinycolor(color1).toRgbString() == tinycolor(color2).toRgbString();
};
tinycolor.random = function() {
    return tinycolor.fromRatio({
        r: mathRandom(),
        g: mathRandom(),
        b: mathRandom()
    });
};
function desaturate(color, amount) {
    amount = (amount === 0) ? 0 : (amount || 10);
    var hsl = tinycolor(color).toHsl();
    hsl.s -= amount / 100;
    hsl.s = clamp01(hsl.s);
    return tinycolor(hsl);
}
function saturate(color, amount) {
    amount = (amount === 0) ? 0 : (amount || 10);
    var hsl = tinycolor(color).toHsl();
    hsl.s += amount / 100;
    hsl.s = clamp01(hsl.s);
    return tinycolor(hsl);
}
function greyscale(color) {
    return tinycolor(color).desaturate(100);
}
function lighten (color, amount) {
    amount = (amount === 0) ? 0 : (amount || 10);
    var hsl = tinycolor(color).toHsl();
    hsl.l += amount / 100;
    hsl.l = clamp01(hsl.l);
    return tinycolor(hsl);
}
function brighten(color, amount) {
    amount = (amount === 0) ? 0 : (amount || 10);
    var rgb = tinycolor(color).toRgb();
    rgb.r = mathMax(0, mathMin(255, rgb.r - mathRound(255 * - (amount / 100))));
    rgb.g = mathMax(0, mathMin(255, rgb.g - mathRound(255 * - (amount / 100))));
    rgb.b = mathMax(0, mathMin(255, rgb.b - mathRound(255 * - (amount / 100))));
    return tinycolor(rgb);
}
function darken (color, amount) {
    amount = (amount === 0) ? 0 : (amount || 10);
    var hsl = tinycolor(color).toHsl();
    hsl.l -= amount / 100;
    hsl.l = clamp01(hsl.l);
    return tinycolor(hsl);
}
function spin(color, amount) {
    var hsl = tinycolor(color).toHsl();
    var hue = (hsl.h + amount) % 360;
    hsl.h = hue < 0 ? 360 + hue : hue;
    return tinycolor(hsl);
}
function complement(color) {
    var hsl = tinycolor(color).toHsl();
    hsl.h = (hsl.h + 180) % 360;
    return tinycolor(hsl);
}
function triad(color) {
    var hsl = tinycolor(color).toHsl();
    var h = hsl.h;
    return [
        tinycolor(color),
        tinycolor({ h: (h + 120) % 360, s: hsl.s, l: hsl.l }),
        tinycolor({ h: (h + 240) % 360, s: hsl.s, l: hsl.l })
    ];
}
function tetrad(color) {
    var hsl = tinycolor(color).toHsl();
    var h = hsl.h;
    return [
        tinycolor(color),
        tinycolor({ h: (h + 90) % 360, s: hsl.s, l: hsl.l }),
        tinycolor({ h: (h + 180) % 360, s: hsl.s, l: hsl.l }),
        tinycolor({ h: (h + 270) % 360, s: hsl.s, l: hsl.l })
    ];
}
function splitcomplement(color) {
    var hsl = tinycolor(color).toHsl();
    var h = hsl.h;
    return [
        tinycolor(color),
        tinycolor({ h: (h + 72) % 360, s: hsl.s, l: hsl.l}),
        tinycolor({ h: (h + 216) % 360, s: hsl.s, l: hsl.l})
    ];
}
function analogous(color, results, slices) {
    results = results || 6;
    slices = slices || 30;
    var hsl = tinycolor(color).toHsl();
    var part = 360 / slices;
    var ret = [tinycolor(color)];
    for (hsl.h = ((hsl.h - (part * results >> 1)) + 720) % 360; --results; ) {
        hsl.h = (hsl.h + part) % 360;
        ret.push(tinycolor(hsl));
    }
    return ret;
}
function monochromatic(color, results) {
    results = results || 6;
    var hsv = tinycolor(color).toHsv();
    var h = hsv.h, s = hsv.s, v = hsv.v;
    var ret = [];
    var modification = 1 / results;
    while (results--) {
        ret.push(tinycolor({ h: h, s: s, v: v}));
        v = (v + modification) % 1;
    }
    return ret;
}
tinycolor.mix = function(color1, color2, amount) {
    amount = (amount === 0) ? 0 : (amount || 50);
    var rgb1 = tinycolor(color1).toRgb();
    var rgb2 = tinycolor(color2).toRgb();
    var p = amount / 100;
    var rgba = {
        r: ((rgb2.r - rgb1.r) * p) + rgb1.r,
        g: ((rgb2.g - rgb1.g) * p) + rgb1.g,
        b: ((rgb2.b - rgb1.b) * p) + rgb1.b,
        a: ((rgb2.a - rgb1.a) * p) + rgb1.a
    };
    return tinycolor(rgba);
};
tinycolor.readability = function(color1, color2) {
    var c1 = tinycolor(color1);
    var c2 = tinycolor(color2);
    return (Math.max(c1.getLuminance(),c2.getLuminance())+0.05) / (Math.min(c1.getLuminance(),c2.getLuminance())+0.05);
};
tinycolor.isReadable = function(color1, color2, wcag2) {
    var readability = tinycolor.readability(color1, color2);
    var wcag2Parms, out;
    out = false;
    wcag2Parms = validateWCAG2Parms(wcag2);
    switch (wcag2Parms.level + wcag2Parms.size) {
        case "AAsmall":
        case "AAAlarge":
            out = readability >= 4.5;
            break;
        case "AAlarge":
            out = readability >= 3;
            break;
        case "AAAsmall":
            out = readability >= 7;
            break;
    }
    return out;
};
tinycolor.mostReadable = function(baseColor, colorList, args) {
    var bestColor = null;
    var bestScore = 0;
    var readability;
    var includeFallbackColors, level, size ;
    args = args || {};
    includeFallbackColors = args.includeFallbackColors ;
    level = args.level;
    size = args.size;
    for (var i= 0; i < colorList.length ; i++) {
        readability = tinycolor.readability(baseColor, colorList[i]);
        if (readability > bestScore) {
            bestScore = readability;
            bestColor = tinycolor(colorList[i]);
        }
    }
    if (tinycolor.isReadable(baseColor, bestColor, {"level":level,"size":size}) || !includeFallbackColors) {
        return bestColor;
    }
    else {
        args.includeFallbackColors=false;
        return tinycolor.mostReadable(baseColor,["#fff", "#000"],args);
    }
};
var names = tinycolor.names = {
    aliceblue: "f0f8ff",
    antiquewhite: "faebd7",
    aqua: "0ff",
    aquamarine: "7fffd4",
    azure: "f0ffff",
    beige: "f5f5dc",
    bisque: "ffe4c4",
    black: "000",
    blanchedalmond: "ffebcd",
    blue: "00f",
    blueviolet: "8a2be2",
    brown: "a52a2a",
    burlywood: "deb887",
    burntsienna: "ea7e5d",
    cadetblue: "5f9ea0",
    chartreuse: "7fff00",
    chocolate: "d2691e",
    coral: "ff7f50",
    cornflowerblue: "6495ed",
    cornsilk: "fff8dc",
    crimson: "dc143c",
    cyan: "0ff",
    darkblue: "00008b",
    darkcyan: "008b8b",
    darkgoldenrod: "b8860b",
    darkgray: "a9a9a9",
    darkgreen: "006400",
    darkgrey: "a9a9a9",
    darkkhaki: "bdb76b",
    darkmagenta: "8b008b",
    darkolivegreen: "556b2f",
    darkorange: "ff8c00",
    darkorchid: "9932cc",
    darkred: "8b0000",
    darksalmon: "e9967a",
    darkseagreen: "8fbc8f",
    darkslateblue: "483d8b",
    darkslategray: "2f4f4f",
    darkslategrey: "2f4f4f",
    darkturquoise: "00ced1",
    darkviolet: "9400d3",
    deeppink: "ff1493",
    deepskyblue: "00bfff",
    dimgray: "696969",
    dimgrey: "696969",
    dodgerblue: "1e90ff",
    firebrick: "b22222",
    floralwhite: "fffaf0",
    forestgreen: "228b22",
    fuchsia: "f0f",
    gainsboro: "dcdcdc",
    ghostwhite: "f8f8ff",
    gold: "ffd700",
    goldenrod: "daa520",
    gray: "808080",
    green: "008000",
    greenyellow: "adff2f",
    grey: "808080",
    honeydew: "f0fff0",
    hotpink: "ff69b4",
    indianred: "cd5c5c",
    indigo: "4b0082",
    ivory: "fffff0",
    khaki: "f0e68c",
    lavender: "e6e6fa",
    lavenderblush: "fff0f5",
    lawngreen: "7cfc00",
    lemonchiffon: "fffacd",
    lightblue: "add8e6",
    lightcoral: "f08080",
    lightcyan: "e0ffff",
    lightgoldenrodyellow: "fafad2",
    lightgray: "d3d3d3",
    lightgreen: "90ee90",
    lightgrey: "d3d3d3",
    lightpink: "ffb6c1",
    lightsalmon: "ffa07a",
    lightseagreen: "20b2aa",
    lightskyblue: "87cefa",
    lightslategray: "789",
    lightslategrey: "789",
    lightsteelblue: "b0c4de",
    lightyellow: "ffffe0",
    lime: "0f0",
    limegreen: "32cd32",
    linen: "faf0e6",
    magenta: "f0f",
    maroon: "800000",
    mediumaquamarine: "66cdaa",
    mediumblue: "0000cd",
    mediumorchid: "ba55d3",
    mediumpurple: "9370db",
    mediumseagreen: "3cb371",
    mediumslateblue: "7b68ee",
    mediumspringgreen: "00fa9a",
    mediumturquoise: "48d1cc",
    mediumvioletred: "c71585",
    midnightblue: "191970",
    mintcream: "f5fffa",
    mistyrose: "ffe4e1",
    moccasin: "ffe4b5",
    navajowhite: "ffdead",
    navy: "000080",
    oldlace: "fdf5e6",
    olive: "808000",
    olivedrab: "6b8e23",
    orange: "ffa500",
    orangered: "ff4500",
    orchid: "da70d6",
    palegoldenrod: "eee8aa",
    palegreen: "98fb98",
    paleturquoise: "afeeee",
    palevioletred: "db7093",
    papayawhip: "ffefd5",
    peachpuff: "ffdab9",
    peru: "cd853f",
    pink: "ffc0cb",
    plum: "dda0dd",
    powderblue: "b0e0e6",
    purple: "800080",
    rebeccapurple: "663399",
    red: "f00",
    rosybrown: "bc8f8f",
    royalblue: "4169e1",
    saddlebrown: "8b4513",
    salmon: "fa8072",
    sandybrown: "f4a460",
    seagreen: "2e8b57",
    seashell: "fff5ee",
    sienna: "a0522d",
    silver: "c0c0c0",
    skyblue: "87ceeb",
    slateblue: "6a5acd",
    slategray: "708090",
    slategrey: "708090",
    snow: "fffafa",
    springgreen: "00ff7f",
    steelblue: "4682b4",
    tan: "d2b48c",
    teal: "008080",
    thistle: "d8bfd8",
    tomato: "ff6347",
    turquoise: "40e0d0",
    violet: "ee82ee",
    wheat: "f5deb3",
    white: "fff",
    whitesmoke: "f5f5f5",
    yellow: "ff0",
    yellowgreen: "9acd32"
};
var hexNames = tinycolor.hexNames = flip(names);
function flip(o) {
    var flipped = { };
    for (var i in o) {
        if (o.hasOwnProperty(i)) {
            flipped[o[i]] = i;
        }
    }
    return flipped;
}
function boundAlpha(a) {
    a = parseFloat(a);
    if (isNaN(a) || a < 0 || a > 1) {
        a = 1;
    }
    return a;
}
function bound01(n, max) {
    if (isOnePointZero(n)) { n = "100%"; }
    var processPercent = isPercentage(n);
    n = mathMin(max, mathMax(0, parseFloat(n)));
    if (processPercent) {
        n = parseInt(n * max, 10) / 100;
    }
    if ((Math.abs(n - max) < 0.000001)) {
        return 1;
    }
    return (n % max) / parseFloat(max);
}
function clamp01(val) {
    return mathMin(1, mathMax(0, val));
}
function parseIntFromHex(val) {
    return parseInt(val, 16);
}
function isOnePointZero(n) {
    return typeof n == "string" && n.indexOf('.') != -1 && parseFloat(n) === 1;
}
function isPercentage(n) {
    return typeof n === "string" && n.indexOf('%') != -1;
}
function pad2(c) {
    return c.length == 1 ? '0' + c : '' + c;
}
function convertToPercentage(n) {
    if (n <= 1) {
        n = (n * 100) + "%";
    }
    return n;
}
function convertDecimalToHex(d) {
    return Math.round(parseFloat(d) * 255).toString(16);
}
function convertHexToDecimal(h) {
    return (parseIntFromHex(h) / 255);
}
var matchers = (function() {
    var CSS_INTEGER = "[-\\+]?\\d+%?";
    var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";
    var CSS_UNIT = "(?:" + CSS_NUMBER + ")|(?:" + CSS_INTEGER + ")";
    var PERMISSIVE_MATCH3 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
    var PERMISSIVE_MATCH4 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
    return {
        CSS_UNIT: new RegExp(CSS_UNIT),
        rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
        rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
        hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
        hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
        hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
        hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
        hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
        hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
    };
})();
function isValidCSSUnit(color) {
    return !!matchers.CSS_UNIT.exec(color);
}
function stringInputToObject(color) {
    color = color.replace(trimLeft,'').replace(trimRight, '').toLowerCase();
    var named = false;
    if (names[color]) {
        color = names[color];
        named = true;
    }
    else if (color == 'transparent') {
        return { r: 0, g: 0, b: 0, a: 0, format: "name" };
    }
    var match;
    if ((match = matchers.rgb.exec(color))) {
        return { r: match[1], g: match[2], b: match[3] };
    }
    if ((match = matchers.rgba.exec(color))) {
        return { r: match[1], g: match[2], b: match[3], a: match[4] };
    }
    if ((match = matchers.hsl.exec(color))) {
        return { h: match[1], s: match[2], l: match[3] };
    }
    if ((match = matchers.hsla.exec(color))) {
        return { h: match[1], s: match[2], l: match[3], a: match[4] };
    }
    if ((match = matchers.hsv.exec(color))) {
        return { h: match[1], s: match[2], v: match[3] };
    }
    if ((match = matchers.hsva.exec(color))) {
        return { h: match[1], s: match[2], v: match[3], a: match[4] };
    }
    if ((match = matchers.hex8.exec(color))) {
        return {
            r: parseIntFromHex(match[1]),
            g: parseIntFromHex(match[2]),
            b: parseIntFromHex(match[3]),
            a: convertHexToDecimal(match[4]),
            format: named ? "name" : "hex8"
        };
    }
    if ((match = matchers.hex6.exec(color))) {
        return {
            r: parseIntFromHex(match[1]),
            g: parseIntFromHex(match[2]),
            b: parseIntFromHex(match[3]),
            format: named ? "name" : "hex"
        };
    }
    if ((match = matchers.hex4.exec(color))) {
        return {
            r: parseIntFromHex(match[1] + '' + match[1]),
            g: parseIntFromHex(match[2] + '' + match[2]),
            b: parseIntFromHex(match[3] + '' + match[3]),
            a: convertHexToDecimal(match[4] + '' + match[4]),
            format: named ? "name" : "hex8"
        };
    }
    if ((match = matchers.hex3.exec(color))) {
        return {
            r: parseIntFromHex(match[1] + '' + match[1]),
            g: parseIntFromHex(match[2] + '' + match[2]),
            b: parseIntFromHex(match[3] + '' + match[3]),
            format: named ? "name" : "hex"
        };
    }
    return false;
}
function validateWCAG2Parms(parms) {
    var level, size;
    parms = parms || {"level":"AA", "size":"small"};
    level = (parms.level || "AA").toUpperCase();
    size = (parms.size || "small").toLowerCase();
    if (level !== "AA" && level !== "AAA") {
        level = "AA";
    }
    if (size !== "small" && size !== "large") {
        size = "small";
    }
    return {"level":level, "size":size};
}
if ( module.exports) {
    module.exports = tinycolor;
}
else {
    window.tinycolor = tinycolor;
}
})(Math);
});

function setAlpha(colorParam, alpha) {
  var tinyColor = tinycolor(colorParam);
  var _a = tinyColor._a;
  if (_a === undefined || _a === null) {
    tinyColor.setAlpha(alpha);
  }
  return tinyColor;
}
function getTinyColor(colorParam) {
  var alpha = colorParam.a || 1;
  if (colorParam.hsl) {
    return setAlpha(colorParam.hsl, alpha);
  }
  if (colorParam.hex && colorParam.hex.length > 0) {
    return setAlpha(colorParam.hex, alpha);
  }
  return setAlpha(colorParam, alpha);
}
function formatColor(colorParam) {
  if (colorParam === '') {
    colorParam = '#FFFFFF';
  }
  var tinyColor = getTinyColor(colorParam);
  var hsl = tinyColor.toHsl();
  var hsv = tinyColor.toHsv();
  if (hsl.s === 0) {
    hsl.h = colorParam.h || colorParam.hsl && colorParam.hsl.h || 0;
    hsv.h = hsl.h;
  }
  if (hsv.v < 0.0164) {
    hsv.h = colorParam.h || colorParam.hsv && colorParam.hsv.h || 0;
    hsv.s = colorParam.s || colorParam.hsv && colorParam.hsv.s || 0;
  }
  if (hsl.l < 0.01) {
    hsl.h = colorParam.h || colorParam.hsl && colorParam.hsl.h || 0;
    hsl.s = colorParam.s || colorParam.hsl && colorParam.hsl.s || 0;
  }
  return {
    hsl: hsl,
    hex: tinyColor.toHexString().toUpperCase(),
    rgba: tinyColor.toRgb(),
    hsv: hsv,
    oldHue: colorParam.h || hsl.h,
    source: colorParam.source,
    a: colorParam.a || tinyColor.getAlpha()
  };
}
function clamp(value, min, max) {
  if (value < min) {
    return min;
  }
  if (value > max) {
    return max;
  }
  return value;
}
function getTouches(e, prop) {
  return e.touches ? e.touches[0][prop] : 0;
}
function toRGBAString(rgba) {
  var r = rgba.r,
      g = rgba.g,
      b = rgba.b,
      a = rgba.a;
  return "rgba(".concat([r, g, b, a].join(','), ")");
}

var script$5 = {
  name: 'SaturationPanel',
  props: {
    colorObj: {
      type: Object,
      required: true
    }
  },
  setup: function setup(props, context) {
    var container = ref(null);
    var backgroundStyle = computed(function () {
      return {
        background: "hsl(".concat(props.colorObj.hsv.h, ", 100%, 50%)")
      };
    });
    var pointerStyle = computed(function () {
      return {
        top: "".concat((1 - props.colorObj.hsv.v) * 100, "%"),
        left: "".concat(props.colorObj.hsv.s * 100, "%")
      };
    });
    return {
      container: container,
      backgroundStyle: backgroundStyle,
      pointerStyle: pointerStyle,
      handleArrowKeydown: handleArrowKeydown,
      handleMouseDown: handleMouseDown
    };
    function handleArrowKeydown(e) {
      var _container$value = container.value,
          clientWidth = _container$value.clientWidth,
          clientHeight = _container$value.clientHeight;
      var left = props.colorObj.hsv.s * clientWidth;
      var top = (1 - props.colorObj.hsv.v) * clientHeight;
      var step = 10;
      switch (e.code) {
        case 'ArrowLeft':
          left = clamp(left - step, 0, clientWidth);
          break;
        case 'ArrowRight':
          left = clamp(left + step, 0, clientWidth);
          break;
        case 'ArrowUp':
          top = clamp(top - step, 0, clientHeight);
          break;
        case 'ArrowDown':
          top = clamp(top + step, 0, clientHeight);
          break;
        default:
          return;
      }
      handlePointChange(null, left, top);
    }
    function handleMouseDown(e) {
      container.value.focus();
      handlePointChange(e);
      window.addEventListener('mousemove', handlePointChange, {
        passive: true
      });
      window.addEventListener('mouseup', handleMouseUp);
    }
    function handleMouseUp() {
      window.removeEventListener('mousemove', handlePointChange);
      window.removeEventListener('mouseup', handleMouseUp);
    }
    function handlePointChange(e, appointedLeft, appointedTop) {
      var _container$value2 = container.value,
          clientWidth = _container$value2.clientWidth,
          clientHeight = _container$value2.clientHeight;
      var left = appointedLeft !== undefined ? appointedLeft : getLeft(e);
      var top = appointedTop !== undefined ? appointedTop : getTop(e);
      var saturation = left / clientWidth;
      var bright = 1 - top / clientHeight;
      changeColor(props.colorObj.hsv.h, saturation, bright, props.colorObj.hsv.a);
    }
    function getLeft(e) {
      var xOffset = container.value.getBoundingClientRect().left + window.pageXOffset;
      var pageX = e.pageX || getTouches(e, 'PageX');
      return clamp(pageX - xOffset, 0, container.value.clientWidth);
    }
    function getTop(e) {
      var yOffset = container.value.getBoundingClientRect().top + window.pageYOffset;
      var pageY = e.pageY || getTouches(e, 'PageY');
      return clamp(pageY - yOffset, 0, container.value.clientHeight);
    }
    function changeColor(h, s, v, a) {
      context.emit('colorChange', {
        h: h,
        s: s,
        v: v,
        a: a,
        source: 'hsva'
      });
    }
  }
};

const _hoisted_1$3 = /*#__PURE__*/createVNode("div", { class: "a-color-picker-saturation-white" }, null, -1 /* HOISTED */);
const _hoisted_2$2 = /*#__PURE__*/createVNode("div", { class: "a-color-picker-saturation-black" }, null, -1 /* HOISTED */);
const _hoisted_3$1 = /*#__PURE__*/createVNode("div", { class: "a-color-picker-circle" }, null, -1 /* HOISTED */);

function render$5(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createBlock("div", {
    ref: "container",
    tabindex: "0",
    class: "a-color-picker-saturation",
    style: _ctx.backgroundStyle,
    onKeydown: _cache[1] || (_cache[1] = (...args) => (_ctx.handleArrowKeydown(...args))),
    onMousedown: _cache[2] || (_cache[2] = withModifiers((...args) => (_ctx.handleMouseDown(...args)), ["stop"]))
  }, [
    createCommentVNode(" 从左到右饱和度 saturation 增大 "),
    _hoisted_1$3,
    createCommentVNode(" 从上到下明度 lightness 减小 "),
    _hoisted_2$2,
    createVNode("div", {
      class: "a-color-picker-pointer",
      style: _ctx.pointerStyle
    }, [
      _hoisted_3$1
    ], 4 /* STYLE */)
  ], 36 /* STYLE, HYDRATE_EVENTS */))
}

script$5.render = render$5;
script$5.__file = "src/components/color-picker/components/saturation-panel.vue";

var script$6 = {
  name: 'HueSlider',
  props: {
    colorObj: {
      type: Object,
      required: true
    }
  },
  setup: function setup(props, context) {
    var container = ref(null);
    var pointerStyle = computed(function () {
      return {
        left: "".concat(props.colorObj.hsv.h / 360 * 100, "%")
      };
    });
    return {
      container: container,
      pointerStyle: pointerStyle,
      handleArrowKeydown: handleArrowKeydown,
      handleMouseDown: handleMouseDown
    };
    function handleArrowKeydown(e) {
      var clientWidth = container.value.clientWidth;
      var left = props.colorObj.hsv.h / 360 * clientWidth;
      var step = 2;
      var hugeStep = 10;
      switch (e.code) {
        case 'ArrowLeft':
          left = clamp(left - step, 0, clientWidth);
          break;
        case 'ArrowRight':
          left = clamp(left + step, 0, clientWidth);
          break;
        case 'ArrowUp':
          left = clamp(left - hugeStep, 0, clientWidth);
          break;
        case 'ArrowDown':
          left = clamp(left + hugeStep, 0, clientWidth);
          break;
        default:
          return;
      }
      handlePointChange(null, left);
    }
    function handleMouseDown(e) {
      container.value.focus();
      handlePointChange(e);
      window.addEventListener('mousemove', handlePointChange, {
        passive: true
      });
      window.addEventListener('mouseup', handleMouseUp);
    }
    function handleMouseUp() {
      window.removeEventListener('mousemove', handlePointChange);
      window.removeEventListener('mouseup', handleMouseUp);
    }
    function handlePointChange(e, appointedLeft) {
      var left = appointedLeft !== undefined ? appointedLeft : getLeft(e);
      changeColor(left / container.value.clientWidth);
    }
    function getLeft(e) {
      var xOffset = container.value.getBoundingClientRect().left + window.pageXOffset;
      var pageX = e.pageX || getTouches(e, 'PageX');
      return clamp(pageX - xOffset, 0, container.value.clientWidth);
    }
    function changeColor(ratio) {
      var _props$colorObj$hsl = props.colorObj.hsl,
          h = _props$colorObj$hsl.h,
          s = _props$colorObj$hsl.s,
          l = _props$colorObj$hsl.l,
          a = _props$colorObj$hsl.a;
      var newHue = ratio * 360;
      if (h !== newHue) {
        context.emit('colorChange', {
          h: newHue,
          s: s,
          l: l,
          a: a,
          source: 'hsl'
        });
      }
    }
  }
};

const _hoisted_1$4 = /*#__PURE__*/createVNode("div", { class: "a-color-picker-hue-rectangle" }, null, -1 /* HOISTED */);

function render$6(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createBlock("div", {
    ref: "container",
    tabindex: "0",
    class: "a-color-picker-hue",
    onKeydown: _cache[1] || (_cache[1] = (...args) => (_ctx.handleArrowKeydown(...args))),
    onMousedown: _cache[2] || (_cache[2] = withModifiers((...args) => (_ctx.handleMouseDown(...args)), ["stop"]))
  }, [
    createVNode("div", {
      class: "a-color-picker-hue-pointer",
      style: _ctx.pointerStyle
    }, [
      _hoisted_1$4
    ], 4 /* STYLE */)
  ], 544 /* HYDRATE_EVENTS, NEED_PATCH */))
}

script$6.render = render$6;
script$6.__file = "src/components/color-picker/components/hue-slider.vue";

var script$7 = {
  name: 'InputContainer',
  props: {
    colorInfo: {
      type: Object,
      required: true
    }
  },
  setup: function setup(props, context) {
    return {
      handleTab: handleTab,
      handleInput: handleInput
    };
    function handleTab() {
      if (props.colorInfo.key === 'a') {
        context.emit('tab');
      }
    }
    function handleInput(e) {
      var key = props.colorInfo.key;
      var value = e.target.value;
      context.emit('inputChange', {
        key: key,
        value: value
      });
    }
  }
};

const _hoisted_1$5 = { class: "a-color-picker-input-part" };
const _hoisted_2$3 = { class: "a-color-picker-input-text" };

function render$7(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createBlock("div", _hoisted_1$5, [
    createVNode("input", {
      type: _ctx.colorInfo.name === 'HEX' ? 'text' : 'number',
      class: ['a-color-picker-input-value', _ctx.colorInfo.error && 'error'],
      value: _ctx.colorInfo.value,
      onKeydown: _cache[1] || (_cache[1] = withKeys((...args) => (_ctx.handleTab(...args)), ["native","tab"])),
      onInput: _cache[2] || (_cache[2] = (...args) => (_ctx.handleInput(...args)))
    }, null, 42 /* CLASS, PROPS, HYDRATE_EVENTS */, ["type", "value"]),
    createVNode("span", _hoisted_2$3, toDisplayString(_ctx.colorInfo.name), 1 /* TEXT */)
  ]))
}

script$7.render = render$7;
script$7.__file = "src/components/color-picker/components/input-container.vue";

var script$8 = {
  name: 'ColorInput',
  components: {
    InputContainer: script$7
  },
  props: {
    colorObj: {
      type: Object,
      required: true
    }
  },
  setup: function setup(props, context) {
    var colorState = reactive({
      hex: {
        key: 'hex',
        name: 'HEX',
        value: props.colorObj.hex,
        error: false
      },
      r: {
        key: 'r',
        name: 'R',
        value: props.colorObj.rgba.r.toString(),
        error: false
      },
      g: {
        key: 'g',
        name: 'G',
        value: props.colorObj.rgba.g.toString(),
        error: false
      },
      b: {
        key: 'b',
        name: 'B',
        value: props.colorObj.rgba.b.toString(),
        error: false
      },
      a: {
        key: 'a',
        name: 'Alpha',
        value: props.colorObj.rgba.a.toString(),
        error: false
      }
    });
    watch(function () {
      return props.colorObj;
    }, function (val) {
      if (tinycolor(val.hex).toString() !== tinycolor(colorState.hex.value).toString()) {
        colorState.hex.value = val.hex;
      }
      colorState.r.value = val.rgba.r.toString();
      colorState.g.value = val.rgba.g.toString();
      colorState.b.value = val.rgba.b.toString();
      colorState.a.value = val.rgba.a.toString();
      validate(colorState);
    });
    return {
      colorState: colorState,
      handleInput: handleInput
    };
    function handleInput(_ref) {
      var key = _ref.key,
          value = _ref.value;
      colorState[key].value = value;
      if (validate(colorState)) {
        var colorStr = key === 'hex' ? colorState.hex.value : "rgba(".concat(colorState.r.value, ", ").concat(colorState.g.value, ", ").concat(colorState.b.value, ", ").concat(colorState.a.value, ")");
        context.emit('colorChange', colorStr);
      }
    }
    function validate(colorState) {
      var result = true;
      var hex = colorState.hex,
          r = colorState.r,
          g = colorState.g,
          b = colorState.b,
          a = colorState.a;
      if (hex.value.startsWith('#') && (hex.value.length === 4 || hex.value.length === 7) && !hex.value.slice(1).match(/[^0-9a-fA-F]/)) {
        hex.error = false;
      } else {
        hex.error = true;
        result = false;
      }
      if (a.value !== '' && a.value >= 0 && a.value <= 1) {
        a.error = false;
      } else {
        a.error = true;
        result = false;
      }
      for (var _i = 0, _arr = [r, g, b]; _i < _arr.length; _i++) {
        var colorInfo = _arr[_i];
        var value = colorInfo.value;
        if (value !== '' && value >= 0 && value <= 255) {
          colorInfo.error = false;
        } else {
          colorInfo.error = true;
          result = false;
        }
      }
      return result;
    }
  }
};

const _hoisted_1$6 = { class: "a-color-picker-input" };
const _hoisted_2$4 = { class: "a-color-picker-input-hex" };
const _hoisted_3$2 = { class: "a-color-picker-input-rgba" };

function render$8(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_InputContainer = resolveComponent("InputContainer");

  return (openBlock(), createBlock("div", _hoisted_1$6, [
    createVNode("div", _hoisted_2$4, [
      createVNode(_component_InputContainer, {
        "color-info": _ctx.colorState.hex,
        onInputChange: _ctx.handleInput
      }, null, 8 /* PROPS */, ["color-info", "onInputChange"])
    ]),
    createVNode("div", _hoisted_3$2, [
      createVNode(_component_InputContainer, {
        "color-info": _ctx.colorState.r,
        onInputChange: _ctx.handleInput
      }, null, 8 /* PROPS */, ["color-info", "onInputChange"]),
      createVNode(_component_InputContainer, {
        "color-info": _ctx.colorState.g,
        onInputChange: _ctx.handleInput
      }, null, 8 /* PROPS */, ["color-info", "onInputChange"]),
      createVNode(_component_InputContainer, {
        "color-info": _ctx.colorState.b,
        onInputChange: _ctx.handleInput
      }, null, 8 /* PROPS */, ["color-info", "onInputChange"]),
      createVNode(_component_InputContainer, {
        "color-info": _ctx.colorState.a,
        onInputChange: _ctx.handleInput,
        onTab: _cache[1] || (_cache[1] = $event => (_ctx.$emit('tab')))
      }, null, 8 /* PROPS */, ["color-info", "onInputChange"])
    ])
  ]))
}

script$8.render = render$8;
script$8.__file = "src/components/color-picker/components/color-input.vue";

var script$9 = {
  name: 'RecommendColors',
  props: {
    colorObj: {
      type: Object,
      required: true
    },
    recommend: {
      type: [Boolean, Array],
      "default": true
    }
  },
  setup: function setup(props, context) {
    var colors = computed(function () {
      return getColorsFromRecommend(props.recommend);
    });
    var selectedIndex = ref(-1);
    var selectedColor = ref(null);
    watch(function () {
      return props.colorObj;
    }, function () {
      selectedIndex.value = -1;
      selectedColor.value = null;
    });
    return {
      isFocused: ref(false),
      colors: colors,
      selectedIndex: selectedIndex,
      selectedColor: selectedColor,
      selectColor: selectColor,
      handleKeydown: handleKeydown
    };
    function handleKeydown(e) {
      if (e.code === 'Tab') {
        context.emit('tab');
      } else {
        var index = 0;
        var rowNum = 10;
        var max = colors.value.length - 1;
        switch (e.code) {
          case 'ArrowLeft':
            index = clamp(selectedIndex.value - 1, 0, max);
            break;
          case 'ArrowRight':
            index = clamp(selectedIndex.value + 1, 0, max);
            break;
          case 'ArrowUp':
            index = clamp(selectedIndex.value - rowNum, 0, max);
            break;
          case 'ArrowDown':
            index = clamp(selectedIndex.value + rowNum, 0, max);
            break;
          default:
            return;
        }
        selectColor(index);
      }
    }
    function selectColor(index) {
      var color = colors.value[index];
      context.emit('colorChange', color);
      nextTick(function () {
        selectedIndex.value = index;
        selectedColor.value = color;
      });
    }
    function getColorsFromRecommend(recommend) {
      if (recommend === true) {
        return ['', '#ff4500', '#ff8c00', '#ffd700', '#90ee90', '#ddffff', '#00ced1', '#3a84ff', '#a933f5', '#db7093', '#000000', '#494949', '#9B9B9B', '#ffffff'];
      } else if (Array.isArray(recommend)) {
        return recommend.map(function (color) {
          return tinycolor(color).isValid() ? color : '';
        });
      } else {
        return [];
      }
    }
  }
};

const _hoisted_1$7 = { class: "a-color-picker-pointer" };
const _hoisted_2$5 = /*#__PURE__*/createVNode("div", { class: "a-color-picker-circle" }, null, -1 /* HOISTED */);

function render$9(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createBlock("div", {
    tabindex: "0",
    class: "a-color-picker-recommend",
    onFocus: _cache[1] || (_cache[1] = $event => (_ctx.isFocused = true)),
    onBlur: _cache[2] || (_cache[2] = $event => (_ctx.isFocused = false)),
    onKeydown: _cache[3] || (_cache[3] = (...args) => (_ctx.handleKeydown(...args)))
  }, [
    (openBlock(true), createBlock(Fragment, null, renderList(_ctx.colors, (color, index) => {
      return (openBlock(), createBlock("div", {
        key: color + index,
        style: { background: color || '#fff' },
        class: ['a-color-picker-recommend-color', _ctx.isFocused && _ctx.selectedIndex === index && 'selected', color === '' && 'empty-color'],
        onClick: $event => (_ctx.selectColor(index))
      }, [
        withDirectives(createVNode("div", _hoisted_1$7, [
          _hoisted_2$5
        ], 512 /* NEED_PATCH */), [
          [vShow, _ctx.selectedIndex === index]
        ])
      ], 14 /* CLASS, STYLE, PROPS */, ["onClick"]))
    }), 128 /* KEYED_FRAGMENT */))
  ], 32 /* HYDRATE_EVENTS */))
}

script$9.render = render$9;
script$9.__file = "src/components/color-picker/components/recommend-colors.vue";

var script$a = {
  name: 'AColorPicker',
  components: {
    AIcon: script,
    APopper: script$4,
    SaturationPanel: script$5,
    HueSlider: script$6,
    ColorInput: script$8,
    RecommendColors: script$9
  },
  props: {
    modelValue: {
      type: String,
      "default": ''
    },
    size: {
      type: String,
      "default": '',
      validator: function validator(val) {
        return ['', 'large', 'small'].includes(val);
      }
    },
    showValue: {
      type: Boolean,
      "default": true
    },
    recommend: {
      type: [Boolean, Array],
      "default": true
    }
  },
  setup: function setup(props, context) {
    var reference = ref(null);
    var showPopper = ref(false);
    var isRenderRecommend = computed(function () {
      return Boolean(props.recommend === true || Array.isArray(props.recommend) && props.recommend.length);
    });
    var _useColorInfo = useColorInfo(props, context),
        colorStr = _useColorInfo.colorStr,
        colorObj = _useColorInfo.colorObj,
        handleColorChange = _useColorInfo.handleColorChange,
        changeColorFromProps = _useColorInfo.changeColorFromProps;
    changeColorFromProps({
      isCreated: true
    });
    watch(function () {
      return props.modelValue;
    }, function () {
      changeColorFromProps();
    });
    onMounted(function () {
      document.addEventListener('click', handleClickOutside);
    });
    onUnmounted(function () {
      console.log('unmounted!');
      document.removeEventListener('click', handleClickOutside);
    });
    return {
      reference: reference,
      isRenderRecommend: isRenderRecommend,
      showPopper: showPopper,
      colorStr: colorStr,
      colorObj: colorObj,
      togglePopper: togglePopper,
      handleColorChange: handleColorChange,
      handleKeydown: handleKeydown,
      handleTabInput: handleTabInput,
      handleTabRecommend: handleTabRecommend
    };
    function closePopper() {
      showPopper.value = false;
      reference.value.focus();
      changeColorFromProps();
    }
    function openPopper() {
      showPopper.value = true;
      nextTick(function () {
        reference.value.querySelector('.a-color-picker-saturation').focus();
      });
    }
    function togglePopper() {
      showPopper.value ? closePopper() : openPopper();
    }
    function handleClickOutside(e) {
      if (!reference.value.contains(e.target)) {
        showPopper.value && closePopper();
      }
    }
    function handleKeydown(e) {
      if (e.code === 'Enter' || e.code === 'NumpadEnter') {
        togglePopper();
      } else if (e.code === 'Escape') {
        showPopper.value && closePopper();
      }
    }
    function handleTabInput() {
      if (!isRenderRecommend.value) {
        reference.value.focus();
      }
    }
    function handleTabRecommend() {
      reference.value.focus();
    }
  }
};
function useColorInfo(props, context) {
  var colorStr = ref('');
  var colorObj = ref(formatColor('#FFFFFF'));
  var handleColorChange = function handleColorChange(val) {
    if (val === '') {
      colorStr.value = '';
      colorObj.value = formatColor('#FFFFFF');
      context.emit('update:modelValue', '');
      return;
    }
    var obj = formatColor(val);
    var str = obj.rgba.a === 1 ? obj.hex : toRGBAString(obj.rgba);
    colorObj.value = obj;
    colorStr.value = str;
    context.emit('update:modelValue', str);
  };
  var changeColorFromProps = function changeColorFromProps() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$isCreated = _ref.isCreated,
        isCreated = _ref$isCreated === void 0 ? false : _ref$isCreated;
    if (props.modelValue === '') {
      if (colorStr.value !== '') {
        colorStr.value = '';
        colorObj.value = formatColor('#FFFFFF');
      }
      return;
    }
    var newColorObj = formatColor(props.modelValue);
    var newColorStr = newColorObj.rgba.a === 1 ? newColorObj.hex : toRGBAString(newColorObj.rgba);
    if (newColorStr !== colorStr.value) {
      var isValid = tinycolor(props.modelValue).isValid();
      if (isCreated) {
        if (!isValid) {
          colorObj.value = formatColor('#FFFFFF');
          context.emit('update:modelValue', '');
        } else {
          colorStr.value = newColorStr.toLowerCase() === props.modelValue.toLowerCase() ? props.modelValue
          : newColorStr;
          colorObj.value = newColorObj;
        }
      } else {
        if (!isValid) {
          colorStr.value = '';
          colorObj.value = formatColor('#FFFFFF');
        } else if (newColorStr.toLowerCase() !== colorStr.value.toLowerCase()) {
          colorObj.value = newColorObj;
          colorStr.value = newColorStr;
        }
      }
    }
  };
  return {
    colorStr: colorStr,
    colorObj: colorObj,
    handleColorChange: handleColorChange,
    changeColorFromProps: changeColorFromProps
  };
}

const _hoisted_1$8 = { class: "a-color-picker-color" };
const _hoisted_2$6 = {
  key: 0,
  class: "a-color-picker-text"
};
const _hoisted_3$3 = { class: "a-color-picker-icon" };
const _hoisted_4 = { class: "a-color-picker-dropdown" };
const _hoisted_5 = { class: "a-color-picker-saturation-container" };
const _hoisted_6 = { class: "a-color-picker-hue-container" };
const _hoisted_7 = { class: "a-color-picker-input-container" };
const _hoisted_8 = {
  key: 0,
  class: "a-color-picker-recommend-container"
};

function render$a(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_AIcon = resolveComponent("AIcon");
  const _component_SaturationPanel = resolveComponent("SaturationPanel");
  const _component_HueSlider = resolveComponent("HueSlider");
  const _component_ColorInput = resolveComponent("ColorInput");
  const _component_RecommendColors = resolveComponent("RecommendColors");
  const _component_APopper = resolveComponent("APopper");

  return (openBlock(), createBlock("div", {
    ref: "reference",
    tabindex: "0",
    class: ['a-color-picker',`a-color-picker-${_ctx.size}` , _ctx.showPopper && 'active', _ctx.showValue && 'a-color-picker-show-value'],
    onKeydown: _cache[1] || (_cache[1] = (...args) => (_ctx.handleKeydown(...args))),
    onClick: _cache[2] || (_cache[2] = (...args) => (_ctx.togglePopper(...args)))
  }, [
    createVNode("div", _hoisted_1$8, [
      createCommentVNode(" 如果传入的色值为空字符串或者没有传值默认白色背景 + 中间一个叉 "),
      (_ctx.colorStr === '')
        ? createVNode(_component_AIcon, {
            key: 0,
            name: "close-bold",
            class: "a-color-picker-color-square"
          })
        : (openBlock(), createBlock("span", {
            key: 1,
            class: "a-color-picker-color-square",
            style: { background: _ctx.colorStr }
          }, null, 4 /* STYLE */))
    ]),
    (_ctx.showValue)
      ? (openBlock(), createBlock("div", _hoisted_2$6, [
          createVNode("span", null, toDisplayString(_ctx.colorStr), 1 /* TEXT */)
        ]))
      : createCommentVNode("v-if", true),
    createVNode("div", _hoisted_3$3, [
      createVNode(_component_AIcon, {
        name: "odd-arrow",
        class: "icon-odd-arrow"
      })
    ]),
    createVNode(_component_APopper, {
      value: _ctx.showPopper,
      reference: _ctx.reference
    }, {
      default: withCtx(() => [
        createVNode("div", _hoisted_4, [
          createCommentVNode(" 饱和度面板 "),
          createVNode("div", _hoisted_5, [
            createVNode(_component_SaturationPanel, {
              "color-obj": _ctx.colorObj,
              onColorChange: _ctx.handleColorChange
            }, null, 8 /* PROPS */, ["color-obj", "onColorChange"])
          ]),
          createCommentVNode(" 色彩条 "),
          createVNode("div", _hoisted_6, [
            createVNode(_component_HueSlider, {
              "color-obj": _ctx.colorObj,
              onColorChange: _ctx.handleColorChange
            }, null, 8 /* PROPS */, ["color-obj", "onColorChange"])
          ]),
          createCommentVNode(" 色彩值 "),
          createVNode("div", _hoisted_7, [
            createVNode(_component_ColorInput, {
              "color-obj": _ctx.colorObj,
              onTab: _ctx.handleTabInput,
              onColorChange: _ctx.handleColorChange
            }, null, 8 /* PROPS */, ["color-obj", "onTab", "onColorChange"])
          ]),
          createCommentVNode(" 预设值 "),
          (_ctx.isRenderRecommend)
            ? (openBlock(), createBlock("div", _hoisted_8, [
                createVNode(_component_RecommendColors, {
                  "color-obj": _ctx.colorObj,
                  recommend: _ctx.recommend,
                  onTab: _ctx.handleTabRecommend,
                  onColorChange: _ctx.handleColorChange
                }, null, 8 /* PROPS */, ["color-obj", "recommend", "onTab", "onColorChange"])
              ]))
            : createCommentVNode("v-if", true)
        ])
      ]),
      _: 1
    }, 8 /* PROPS */, ["value", "reference"])
  ], 34 /* CLASS, HYDRATE_EVENTS */))
}

script$a.render = render$a;
script$a.__file = "src/components/color-picker/color-picker.vue";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
var components = {
  AIcon: script,
  AButton: script$1,
  AInput: script$2,
  ALoading: script$3,
  APopper: script$4,
  AColorPicker: script$a
};
var plugin = {
  install: function install(app) {
    for (var _i = 0, _Object$entries = Object.entries(components); _i < _Object$entries.length; _i++) {
      var _Object$entries$_i = slicedToArray(_Object$entries[_i], 2),
          key = _Object$entries$_i[0],
          value = _Object$entries$_i[1];
      app.component(key, value);
    }
  }
};
var index = _objectSpread({
  install: plugin.install
}, components);

export default index;
